



\chapter{Anforderung an die Lösung}
Es soll eine Lösung gefunden werden, bei der mittels Methoden des Information-Hidding Daten übertragen werden können. Dabei sollen beliebige Formate versendet werden können. Zudem soll er unauffällig sein und mit höchst möglicher Übertragungsgeschwindigkeit funktionieren. Die Lösungsidee muss sich als Algorithmus umsetzen lassen und soll möglichst nicht von Netzwerkbedingungen abhängig sein. Die Lösung darf sich nicht von Netzwerk Normaliesierungen beeinflussen lassen.\\ 
Eine Methode zur Sicherstellung der Integrität soll implementierbar sein und eine Umsetzung als passiven Covert Channel ist wünschenswert. 
%TODO     

\chapter{Lösungsansätze}
\label{cha:Covert-Channel} %Label des Kapitelsne bereit

Im folgenden Kapitel werden verschiedene, bereits existierende steganographische Covert Channel betrachtet, die für das Erreichen der Zielsetzung in Frage kommen.

\section{Covert Channel}

\subsection{Zeitabhängige Covert Channel}

Bei zeitabhängigen Covert Channel werden die Daten so versendet, dass der Absendezeitpunkt oder der Abstand zwischen den Paketen die geheime Information enthält. Dabei ähnelt dieses Verfahren dem in der Vergangenheit oft eingesetzten Morse Code und beschränkt sich meistens auf Binärdaten.
\begin{figure}[ht]
	\centering
	\includegraphics*[height=10cm]{bilder/timing.png}
	\caption{Kommunikation über einen Zeitabhängigen Kanal \cite{cabuk2004ip}}
	\label{fig5}
\end{figure}

Bei dem in Abbildung 4.1 dargestellten Covert Channel wird mit einem festen Zeitintervall gearbeitet. Dieses Zeitintervall muss sowohl dem Sender, sowie dem Empfänger bekannt sein. Wird ein Datenpaket innerhalb des Zeitintervalls gesendet, wird dies als 1 interpretiert, falls kein Paket gesendet wird als 0.
So lassen sich beliebige Daten übertragen.\cite{cabuk2004ip}

Da die Datenübertragung sehr stark von der Netzwerkgeschwindigkeit abhängig ist, muss man zusätzlich ein Verfahren zur Sicherstellung der Integrität implementieren.\\ 
Durch das Versenden des Hashwertes, der über einen bestimmten Anteil der Nachricht gebildet wird, kann die Integrität garantiert werden.\\
Eine andere Methode, bei der die Integrität jedoch nicht vollständig garantiert, aber simpler umzusetzen ist, ist die Verwendung eines Paritätsbit.\cite{cabuk2004ip}

\begin{figure}[ht]
	\centering
	\includegraphics*[height=10cm]{bilder/Zeitacuracyzusammenhang.png}
	\caption{Zusammenhang zwischen Zeitintervall und Genauigkeit \cite{cabuk2004ip}}
	\label{fig6}
\end{figure}

Die Datenübertragung über diesen Channel ist mit einem Bit pro Paket relativ gering. Die Datenübertragung ist hier aber auch direkt vom verwendeten Zeitintervall abhängig. Deshalb gilt es, ein möglichst kleines Zeitintervall zu wählen und dieses optimal an die herrschenden Netzwerkbedingungen anzupassen.

Die Problematik besteht, dass mit der Reduzierung des Netzwerkintervalls die Fehleranfälligkeit ebenfalls zunimmt. Abbildung 4.2 zeigt, wie das gewählte Zeitintervall und die Genauigkeit zusammenhängen. So lässt sich bei einer langsamen Datenübertragung mit einem Intervall von 0.05 Sekunden eine Genauigkeit von ca. 100 Prozent garantieren. Diese Zahlen sind jedoch sehr stark vom jeweiligen Netzwerk abhängig.
Der Ersteller dieser Grafik\cite{cabuk2004ip} hat ebenfalls einen Wert $k$ in seine Implementierung eingebaut, der die Länge einer Pause angibt, die bei einer Übertragungsverzögerung eingelegt werden kann. Diese verbessert zwar die Genauigkeit der Datenübertragung, die Geschwindigkeit wird aber erheblich reduziert.

Beim zeitabhängigen Covert Channel kann jedes beliebige Protokoll eingesetzt werden. Es bietet sich an, die Protokolle auf den umliegenden Netzwerkverkehr anzupassen, um ihn so unauffällig wie möglich zu machen.


\subsection{Storage Channel}

Bei Storage Channels benutzt man Speicherattribute\cite{wendzel2012tunnel} in Protokollheadern, um unbemerkt Daten zu übertragen. Da in dieser Arbeit über Netzwerkgrenzen hinaus kommuniziert werden soll, wird hier mit dem Internet Protokoll begonnen.


\subsubsection{IPv4}

Der IPv4 Header bietet einige Möglichkeiten Daten in Speicherattribute (vergleiche Kapitel Grundlagen) zu verstecken. Folgend werden die Attribute begutachtet, die Potential zur Manipulation bietet.

\textbf{Type of Service:} \\
Die letzten beiden Bits dieses Feldes sind unbenutzt und können so zur Datenübertragung verwendet werden. (2 Bits)

\textbf{Identification:} \\
Bietet 16 Bits die theoretisch frei wählbar sind. (16 Bits)

\textbf{Reserved Flag:} \\
Das erste Bit der Flags ist für zukünftige Benutzung reserviert und ist derzeit noch unbenutzt. (1 Bit)

\textbf{Fragment Offset:} \\
Der Fragment Offset wird dazu verwendet, um Pakete nach einer Fragmentierung wieder zusammenzusetzen. Geht man davon aus, dass die Paket Fragmente sich frei konfigurieren lassen bietet sich die Chance 13 Bit zu verwenden. In Realität liegt die Nutzbarkeit der Bits deutlich tiefer. (< 13 Bit)

\textbf{Time to Live:} \\
Dieses 8 Bit Feld lässt sich frei wählen. Jedoch muss man bei der Benutzung wissen, wie viele Netzwerkstationen, die dieses Feld herunterzählt, auf dem Weg liegen. Ein zu kleiner Wert kann dazu führen, dass die Nachricht nicht ankommt.
(< 8 Bit)

\textbf{Total Length:} \\
Die Gesamtlänge des Pakets lässt sich auch manipulieren. Diese Länge wird mit einem 16 Bit Wert angegeben. Jedoch ist dieser Wert durch die Mindestgröße eingeschränkt. Durch Fragmentierung des Pakets oder das Hinzufügen von Optionen ändert sich dieser Wert. (< 16 Bit)

\textbf{Options:} \\
Dem Ip-Header können Optionen hinzugefügt werden, in die sich ebenfalls Daten einbetten lassen.

\textbf{Padding:} \\
Die durch das IHL Feld angegebene Headerlänge muss ein Vielfaches von 4 Byte erreicht werden. Durch die Verwendung von Options wird diese Länge nicht immer erreicht und wird deshalb mit Padding aufgefüllt. Dieses Padding lässt sich theoretisch auch umwandeln und zur Datenübertragung verwenden.

\subsection{IPv6}
Bei IPv6 kann man in der Regel die äquivalenten Speicherattribute verwenden, wie bei IPv4. Hier unterscheidet sich meistens nur die Namensgebung. \cite{wendzel2012tunnel}

\subsection{TCP}
Im TCP Protokoll bieten sich ebenfalls Möglichkeiten Daten unbemerkt zu transportieren. So kann der Source Port zur Codierung verwendet werden. Bei der Benutzung des optionalen TCP Timestamps, können die letzten Bits manipuliert werden.
\cite{wendzel2012tunnel}

Eine weitere Möglichkeit ist das Manipulieren der Sequence Number.\cite{wendzel2012tunnel} Diese Nummer gibt die Reihenfolge der Datenpakete an.
Dabei wird sie am Anfang der Datenübertragung vom Sender errechnet und anschließend alle 4 Mikrosekunden um eins hochgezählt. Sollte diese 32-Bit-Nummer überlaufen, so wird sie wieder auf Null zurückgesetzt. So wird sichergestellt, dass jedes Paket eine einzigartige Sequence Number bekommt\cite{TCP_RFC}\\
Um diese Nummer zu verändern, muss eine Übersetzungsschicht eingebaut werden, die die übertragenen Geheimdaten abfängt und wieder mit der richtigen Sequence Number ersetzt.\cite{wendzel2012tunnel}


\subsection{Traffic Normalizers}
Storage Channels haben einen großen Schwachpunkt: Traffic Normalizer schreiben die oben beschriebenen Headerattribute gezielt um, oder verwerfen diese, wenn auffällige Werte gesetzt sind. \\
Ein Traffic Normalizer auf IP Ebene könnte zum Beispiel das TTL Feld manipulieren, die Flags ,,Don't Fragment'' und ,,Reserved'' auf 0 setzen, die Options löschen, oder Pakete bei denen das IHL Feld größer als 5 ist verwerfen. \cite{wendzel2012problem}\\
Das Padding und die ungenutzten Bits des ,,Type of Service'' Feldes auf 0 können gesetzt werden.\\
Ein solches System, in ähnlicher Weise auf alle Netzwerkschichten angewendet, ist eine sehr effektive Methode um gegen Storage Channels vorzugehen. 



\subsection{Benutzung verschiedener Protokolle}

Covert Channels können durch die Verwendung verschiedener Protokolle realisiert werden. Hier kann man zwischen Protocol Hopping Covert Channels und Protocol Channels unterscheiden. \cite{wendzel2012tunnel}

\subsubsection{Protocol Channels}

Beim Protocol Channel werden die Daten mit Hilfe mehrerer Protokolle kodiert.
Eine mögliche Kodierung könnte folgende sein:

HTTP -> 00 \tab
DNS  -> 01\\
ICMP -> 10\tab
POP3  -> 11\\
 \cite{wendzel2012tunnel}

So ist man in der Lage binäre Daten mit vier Protokollen zu versenden. In Abbildung 4.3 ist dieses Prinzip veranschaulicht.


\begin{figure}[ht]
	\centering
	\includegraphics*[height=9cm]{bilder/protoChannel.png}
	\caption{Protokol Channel \cite{wendzel2012tunnel}}
	\label{fig7}
\end{figure}

Die Wahl der Protokolle ist hier abhängig von den im Netzwerk verwendeten Protokollen. Natürlich funktioniert dieses Prinzip auch mit zwei Protokollen. Denkbar wäre hier die Verwendung von IPv4 und IPv6, da diese Protokolle unter Umständen unterschiedliche Wege durchs Internet nehmen und so noch unauffälliger werden.
Wie auch bei den zeitabhängigen Covert Channel beträgt hier die Übertragungsrate 1 oder 2 Bit pro Paket. Die Übertragungsgeschwindigkeit wird durch die Netzwerkgeschwindigkeit eingeschränkt.\\

Eine denkbare Unterart dieses Kanals ist die Verwendung verschiedener Options im Header, wodurch die Codierung realisiert wird.

\subsubsection{Protocol Hopping Covert Channel}

Dieser Kanal ist eine Mischung des Protocol Channel und des Storage Channel. Dabei werden verschiedene Storage-Channels zu einem zusammengefasst und abwechselnd Daten übertragen.

In Abbildung 4.4 wird dargestellt, wie dies realisiert werden kann. Die Binärdaten werden hier über zufällig gewählte Storage Channel übertragen. Dadurch wird bewirkt, dass der Kanal unauffälliger wird, da sich ein reales Netzwerk simulieren lässt.

Im Beispiel unten werden jeweils 4 Bit an den Storage Channel übergeben und an den Empfänger weitergeleitet.

\begin{figure}[ht]
	\centering
	\includegraphics*[height=9cm]{bilder/protoHopingChan.png}
	\caption{Protokol Hoping Covert Channel \cite{wendzel2012tunnel}}
	\label{fig8}
\end{figure}

\subsection{Verwendung der Nutzdatengröße}
Die Größe des Pakets lässt sich über die Versendung unterschiedlicher Daten einfach manipulieren. Daraus ergeben sich etliche Varianten, um einen Covert Channel zu erschaffen. Beispielsweise kann zwischen großen/kleinen Paketen oder gerade/ungerade Datenanzahl unterschieden und so binär Daten übertragen werden.\\
Aber auch direkt in der Größe der Nutzdaten können Informationen versteckt werden:\\
Will man 8 Bit pro Paket übertragen, benötigt man die Werte von 0 bis 255. Die Größe der Nutzdaten muss so angepasst werden, dass sie jeweils den zu übertragenden Werten entspricht. Da Nutzdaten von null oder einem Byte relativ selten sind, empfiehlt sich die Verwendung eines statischen oder flexiblen Offsets, der addiert wird, um die Paketgröße anzuheben.\\
Dieser Kanal lässt sich auf alle Protokolle, die zur Datenübertragung fähig sind, anwenden.



\section{Steganographie}

\subsection{Klassische textbasierende Verfahren}

Botschaften in Texten teilweise einzubetten ist mit der Steganographie möglich.
Gängig unter Textmanipulatoren ist die gezielte Wahl des ersten Buchstaben des Wortes, wobei die Aneinanderreihung dieser Buchstaben ein neues Wort ergibt.
Bei einem wissenschaftlich erarbeiteten Rückblick treten einige, nicht zu unterschätzende, Sicherheitslücken auf, wenn diese Art der Verschlüsselung angewendet wird.

(Im oberen Text ist zur Veranschaulichung eine Nachricht an einen potentiellen Prüfer eingebettet. Nach jedem sinnvollen deutschem Wort muss mit dem nächsten Satz begonnen werden)

Eine weitere Methode ist, die Satzzeichen zu verwenden, um Informationen zu kodieren. So kann zum Beispiel ein Punkt 00, ein Komma 01, ein Fragezeichen 10 und ein Ausrufezeichen 11 bedeuten.\cite{lockwood2017text}

Durch diese Verfahren lassen sich versteckte Datenkanäle konstruieren indem ein solcher Text beispielsweise per E-Mail versendet wird.

\subsection{Basierend auf RGB Bilder}

Bildformate, die auf dem RGB Formaten basieren, sind zum Beispiel BMP (Windows Bitmap) oder auch GIF (Graphics Interchange Format). Diese Formate zeigen die Pixelfarbe basierend auf dem \textbf{R}ot-, \textbf{G}rün- und \textbf{B}lauwert. In diesen Werten können Daten versteckt werden.\cite{katzenbeisser2000information} So können beispielsweise die letzten beiden Bits manipuliert werden. Diese Veränderung ist für das menschliche Auge nicht zu erkennen, da die letzten Bits kaum eine Auswirkung auf die Höhe der Zahl haben.\\
Bei einer Farbtiefe von 24 Bit beträgt die maximale Änderung der Farbwerte nur 3 Farbstufen von insgesamt 256 möglichen.

00000000 (0) 		-> 00000011 (3)\\
11111111 (255)		-> 11111100	(252)

Auf diese Weise lassen sich 6 Bit pro Pixel übertragen. In einem unkomprimierten HD Bild mit einer Auflösung von 1280x720 Pixeln (ca. 22 MByte) lassen sich 0,6912 Mbyte Daten übertragen.

In Abbildung 4.5 wird dieses System veranschaulicht:

\begin{figure}[ht]
	\centering
	\includegraphics*[height=10cm]{bilder/stgRGB.jpg}
	\caption{Codierung in den 2 letzten Bits \cite{Black2018Slash}}
	\label{fig4}
\end{figure}

\subsection{Bildformate mit Alpha Kanal}
Bildformate wie PNG (Portable Network Graphics) können zusätzlich zu den RGB Kanälen auch einen Alpha Kanal besitzen. Dies ist ein zusätzlicher Wert der die Transparenz des jeweiligen Pixel angibt.
Bei einem Wert von 0 ist der Pixel ,,unsichtbar'' und bei 255 ist der Pixel komplett sichtbar.
Hier könnte man die Daten wie oben in den letzten beiden Werten speichern.\\
Da die Transparenz keine direkte Auswirkung auf die Farbe der Pixel hat, kann man unbemerkt auch mehr Daten speichern.

\subsubsection{Verwendung von ,,Shamir's Secret Sharing'' Methode}

Das in Kapitel 2.4.3 beschriebene Verfahren kann man dazu verwenden, um Nachrichten unauffällig in den Alpha Kanal eines PNG Bildes zu integrieren.\\
Die zu übertragende Nachricht $M$ wird hierzu in Segmente von $t$ Bit, mit $t=3$ unterteilt. Bei der Umwandlung der Segmente in Dezimalzahlen entsteht so ein neues Array $M'=d_1,d_2...$ bei dem die Werte zwischen 0 und 7 liegen.

Im Gegensatz zu dem original Algorithmus greift man hier zusätzlich auf die Werte $c_1$, $c_2$ und $c_3$ zurück, um hier ebenfalls ein ,,Geheimnis'' einzubetten. Zusammen mit $d$ können nun $k$ Werte integriert werden.

So ergibt sich:

$d = m_1 , c_1 = m_2 , c_2 = m_3 ,  c_3 = m_4$


Folgende Werte werden definiert:

$p = 11$\\
$x_1=1,x_2=2,x_3=3,x_4=4$

x kann hier eine beliebige Zahl annehmen und so als eine Art Verschlüsselung dienen. Fraglich ist, ob es sich dann noch um reine Steganographie handelt.

Die Werte von $q_1$ bis $q_4$ ergeben sich dann durch Einsetzen in die Polynomgleichung.

$q_1 = F(x_1 ) = (m_1 + m_2 x_1 + m_3 {x_1}^2 + m_4 {x_1}^3 ) mod(p)$\\
$q_2 = F(x_2 ) = (m_1 + m_2 x_2 + m_3 {x_2}^2 + m_4 {x_2}^3 ) mod(p)$\\
$q_3 = F(x_3 ) = (m_1 + m_2 x_3 + m_3 {x_3}^2 + m_4 {x_3}^3 ) mod(p)$\\
$q_4 = F(x_4 ) = (m_1 + m_2 x_4 + m_3 {x_4}^2 + m_4 {x_4}^3 ) mod(p)$\\



Die Werte $q_1$ bis $q_4$ können nun  in den Alpha Kanal eines PNG Bildes eingefügt werden.
Durch die Modulo Funktion entstehen so Werte zwischen 0 und 10. Damit das Bild eine möglichst niedrige Transparenz bekommt, muss der alpha Wert so groß wie möglich sein. Deshalb wird zu $q$ jeweils der Wert 245 addiert, um so nah wie möglich an 255 zu kommen.\\
Die neu entstandenen Werte $q'_1$ bis $q'_4$ kann man nun in den Alpha Kanal einfügen und über eine sensible Datenverbindung übertragen.\\


Zum Entschlüsseln muss man nun wieder 245 von den Werten des Alpha Kanal subtrahieren. Durch das Erstellen und Lösen des Gleichungssystems, mit den oben gezeigten Formeln, können die Werte $m_1$ bis $m_4$ wieder berechnet werden.

\cite{lee2010new}



\subsection{Verwendung von PDF Dateien}

Auch in PDF Dateien können Daten versteckt eingebettet werden. Das PDF Format setzt sich aus einer Reihe von Befehlen zusammen, in der die Formatierung der Seite angegeben wird. So können Elemente zur Positionierung von Texten eingesetzt werden, um Informationen einzubetten.\cite{zhong2007data}
Open Source Programme machen es für jeden möglich auf diese Weise Daten zu verstecken.

\chapter{Bewertung der Covert Channel}
In diesem Kapitel wird sich damit beschäftigt, welcher der im vorhergehenden Kapitel vorgestellten Covert Channel für die Problemstellung geeignet ist. Es soll nun der optimale Kanal gefunden werden, der das Problem der Kommunikation zwischen Polizeipräsidium und Informant lösen kann.

Betrachtet man die \textbf{Textbasierenden Verfahren} etwas genauer wird schnell klar, dass diese nicht für größere Datenmengen geeignet sind und sich auch sehr schwierig als Algorithmen darstellen lassen.

Die \textbf{Zeitabhängigen Verfahren} sind sehr unauffällig, da die Datenpakete nicht direkt manipuliert werden müssen. Es muss sich jedoch um die Integrität der Daten gekümmert werden, da der Kanal sehr stark von den Netzwerkbedingungen abhängt. Die Übertragungsgeschwindigkeit ist mit einem Bit pro Paket sehr gering. Jedoch lässt sich dieser Kanal sehr gut als passiver Covert Channel realisieren.

\textbf{Storage Channels} sind relativ auffällig, vor allem wenn die Pakete genauer angeschaut werden. Zudem gibt es das Problem der Netzwerk Normalisierung, die den Storage Channel stark einschränken würde.
Die Methode, bei der die TCP Sequence Number manipuliert wird, ist hingegen für dieses Projekt denkbar, da sie nicht durch die Normalisierung verändert werden kann und pro Paket 32 Bit übertragen kann. Bei einer sehr genauen Analyse kann hier aber auffallen, dass die Nummern nicht in der richtigen Reihenfolge versendet werden.

\textbf{Protocol Channels} sind im Gegensatz zu zeitabhängigen Verfahren nicht von den Netzwerkbedingungen abhängig und machen so ein Verfahren gegen Integritätsverlust überflüssig.\\
Es ist schwierig einen realen Netzwerkkanal zu realisieren, da die Reihenfolge der Pakete/Protokolle zufällig ist. Dies ist bei realen Netzwerken nicht der Fall. So kommen zum Beispiel DNS Anfragen viel seltener vor als TCP Pakete.\\
Die Veränderung der Pakete ist bei diesem Covert Channel nicht nötig. Eine Implementierung als passiver Channel ist aber nicht möglich, da von einem beliebigen Server nicht die benötigte Vielzahl an Protokollen geliefert wird.

\textbf{Projekt Hopping Channels} haben die gleichen negativen Eigenschaften wie die Storage Channels und kommen deshalb nicht für dieses Projekt in frage.

Die Verwendung der \textbf{Nutzdatengröße} für die Datenübertragung ist sehr unauffällig. Die Pakete bleiben bis auf die Nutzdaten regulär und ziehen so fast keine Aufmerksamkeit auf sich. Der Kanal ist nicht von Netzwerkbedingungen abhängig und die Datenübertragung kann 8 Bit pro Paket betragen.
Es muss jedoch eine unauffällige Methode ausgearbeitet werden, bei der es möglich ist, variable Datenpakete zu versenden. Es ist hier ebenfalls nicht möglich, den Kanal passiv zu gestalten.

Werden \textbf{Bilddateien} zum Einbetten der Daten verwendet, muss sich überlegt werden, wie die Übertragung der Bilder stattfinden soll. Hier muss eine unauffällige Möglichkeit gefunden werden, um diesen Austausch zu realisieren.
Hier lassen sich viele Daten auf einmal überragen. Hingegen ist diese Methode vor allem durch die Medien sehr bekannt geworden. Ein aktuelles Beispiel ist eine Sicherheitslücke in Android, indem durch das Öffnen eines PNG Bildes, Schadcode mit den Rechten des Benutzers ausgeführt werden kann.\cite{HEISE_ANDROID}.
                                  

Da der zeitabhängige Covert-Channel die Pakete nicht manipulieren muss und beim Netzwerkverkehr, bis auf den zeitlichen Offset, keine Veränderung vorgenommen werden muss, soll dieses Projekt mit diesem Kanal durchgeführt werden. Zudem ist die Möglichkeit gegeben, den Channel passiv zu realisieren. Die allgemeine Unbekanntheit des Channels ist ein weiterer positiver Aspekt.

\chapter{Umsetzung des Projekts}

\section{Konstruktion des Covert Channels}

Wie in den Grundlagen schon beschrieben, kann man einen Covert Channel mit folgender Formel veranschaulichen:

\textit{Covert Channel = Geheime Daten + Trägerkanal + Schlüssel (Manipulation der Kommunikationsattribute)}\\
 
\subsection{Geheime Daten}
Die geheimen Daten beinhalten die Informationen, welche versteckt übertragen werden. Diese sollen jedes beliebige Format annehmen können. Zum Senden werden die Daten in ihre binäre Form übertragen. So muss man sich keine Sorge um das Datenformat machen.\\ Da eine sehr geringe Übertragungsgeschwindigkeit erwartet wird, ist es hilfreich, wenn diese Daten so klein wie möglich ausfallen.\\
Zum Entwickeln wird hierzu die Datei $test.txt$ verwendet, die als Inhalt den String ,,Hallo Welt'' besitzt.


\subsection{Schlüssel}
Der Schlüssel bildet sich aus dem, im vorhergehenden Kapitel gewählten, Covert Channel. Er bestimmt auf welche Art die Daten in den Träger infiltriert und später exfiltriert werden.\\
Aufgrund der Wahl des zeitabhängigen Covert Channel können folgende Schlüssel definiert werden. 

Schlüssel zur Dateninfiltration:

\textit{Manipuliere den Datenstrom des Trägerkanals so, dass die geheimen Daten kodiert werden.}

Schlüssel zur Datenexfiltration:

\textit{Lese die Zeitabstände der Datenpakete im Trägerkanal und dekodiere diese.}


\subsection{Trägerkanal}
Es wird ein Trägerkanal benötigt in diesen die geheimen Nachrichten eingebettet werden sollen.\\
Für den gewählten Covert Channel kann prinzipiell jedes Netzwerkprotokoll verwendet werden. Da die Übertragung über Netzwerkgrenzen hinaus stattfinden soll muss jedoch mindestens das Internet Protokoll verwendet werden. 
Die Verwendung von ICMP Paketen ist durch die Filterung von Firewalls nicht geeignet. Die verbleibenden und sinnvollen Möglichkeiten sind demnach entweder TCP oder UDP.\\ Da immer nur ein Bit durch ein Datenpaket übertragen wird, wird ein Datenstrom (Stream) mit vielen Datenpaketen benötigt.\\
Die Entscheidung beschränkt sich nun auf einen UDP oder TCP Stream. UDP hat das Problem, dass es sich hierbei um ein verbindungsloses Protokoll handelt und man nicht sicher sein kann, dass die Daten in der richtigen Reihenfolge oder überhaupt ankommen. Durch die Verwendung eines zeitlichen Covert Channel, muss aber sowieso ein System zur Sicherstellung der Integrität implementiert werden.\\
Auf der anderen Seite sind UDP Pakete selten geworden, da HTTP und somit die Webserver auf TCP aufbauen. Auch die Streams von Firmen wie Netflix oder YouTube basieren heute alle auf dem TCP/IP Stack.\\
So ist die Verwendung eines TCP Streams die beste Lösung, wobei sich die verbindungsorientierte Datenübertragung von TCP zusätzlich positiv auf die Zuverlässigkeit des Datenkanals auswirkt wird.



\section{Aufbau des Systems}

In diesem Kapitel sollen die einzelnen Bausteine, die im vorhergehenden Abschnitt beschriebenen wurden, zu einem kompletten System zusammengefügt werden. Der Aufbau dieses Systems dient dann später als Struktur bei der Programmierung.\\
Im Allgemeinen können hier zwei Systeme entstehen, entweder ein System mit einem aktiven oder passiven Covert Channel.

\subsection{Aktiv}
Soll ein aktiver Covert Channel erstellt werden, so ist der Sender gleichzeitig als Server realisiert. Dieser sendet aktiv Datenpakete an den Empfänger. Durch die Codierung der geheimen Nachricht in die Zeitabstände zwischen den Paketen, gelangt die Information zum Empfänger. In \textit{Abbildung 6.1} wird dieses System vereinfacht dargestellt.\\

\begin{figure}[h!]
	\centering
	\includegraphics*[height=8cm]{bilder/Activ.png}
	\caption{Aufbau eines aktiven Systems}
	\label{fig9}
\end{figure}


\subsection{Passiv}

Bei der passiven Alternative verbindet sich der Empfänger über einen Proxy mit einem beliebigen Webserver, der einen konstanten Datenstrom generiert. Dies könnte zum Beispiel ein Video- oder Audiostream sein.\\
Dieser Datenstrom läuft über den Proxy, der nun die Möglichkeit hat, den Datenstrom zu manipulieren. Der Sender der geheimen Nachrichten nimmt in diesem System die Rolle des Proxys ein. Er muss die Daten nicht verändern, sondern nur verzögern.

\begin{figure}[h!]
	\centering
	\includegraphics*[height=8cm]{bilder/Passiv.png}
	\caption{Aufbau eines passiven Systems}
	\label{fig10}
\end{figure}


\subsection{Bewertung des Aufbaus}
Die aktive Variante bietet eine gute Grundlage, um die Methode eines zeitabhängigen Covert Channel zu beweisen und die Funktion zu testen. Außerdem hat man bei dieser Variante die volle Kontrolle über die versendeten Datenpakete und kann so wichtige Parameter genau bestimmen.\\
Wird die passive Umsetzung realisiert, bekommt man als Ergebnis eine flexible Lösung die jede Webseite nutzen kann. Da große Teile des aktiven Lösungsansatzes beim passiven wiederverwendet werden können, soll in diesem Projekt zunächst der aktive und als Erweiterung der passive Covert Channel realisiert werden.

\section{Kodierung und Dekodierung}

Der folgende Abschnitt beschäftigt sich damit, wie die Daten in den Trägerkanal codiert werden können, indem nur der Zeitpunkt des Versendens manipuliert wird.\\
Folgend werden zwei Methoden vorgestellt, die zur Kodierung der Binärdaten in Frage kommen.


\subsection{Mit festen Zeitrastern}

Das in \cite{cabuk2004ip} vorgestellte Verfahren basiert auf einer Generierung von Zeitintervallen. Diese werden sowohl beim Sender und Empfänger erstellt. Dabei haben die Intervalle des Empfängers einen zeitlichen Offset, der ungefähr der Übertragungsdauer entspricht. Dies dient dazu, dass Pakete die vom Sender abgesendet werden, beim Empfänger im gleichen Intervall ankommen.
Nachdem Sender und Empfänger synchronisiert sind, kann man mit der Datenübertragung starten.
Dabei wird ein Paket, dass in einem Zeitintervall ankommt als binäre 1 interpretiert. Kommt kein Paket so wird eine 0 geschrieben.
Durch die Wahl längerer Zeitintervalle kann die Fehleranfälligkeit verringert werden, wobei jedoch die Übertragungsgeschwindigkeit ebenfalls abnimmt.\\
Für diese Art der Codierung ist es unabdingbar, dass die Uhren von Sender und Empfänger möglichst genau übereinstimmen.\\ Zur Veranschaulichung ist die Kodierung in \textit{Abbildung 6.3} schematisch dargestellt.

\begin{figure}[h!]
	\centering
	\includegraphics*[height=8cm]{bilder/Raster.png}
	\caption{Kodierung mit festen Zeitrastern}
	\label{fig11}
\end{figure}


\subsection{Basierend auf den Paketabständen}

Zur Kodierung kann ebenso die Veränderung der Paketabstände benutzt werden. Hierzu wird zwischen einer kleinen oder großen Pause zwischen zwei Nachrichten unterschieden. Eine große Pause wird als binäre 1 interpretiert, eine kleine Pause als 0.\\
Je nachdem, wie gut die Netzwerkbedingungen sind, kann hier durch eine gezielte Verkleinerung der Pausen eine Erhöhung der Übertragungsgeschwindigkeit generiert werden. Durch eine Verlängerung dieser Pausen sinkt jedoch die Fehleranfälligkeit.\\
Zu sehen ist diese Art der Kodierung in \textit{Abbildung 6.4}

\begin{figure}[h!]
	\centering
	\includegraphics*[height=6cm]{bilder/Morse.png}
	\caption{Kodierung anhand der Paketabstände}
	\label{fig12}
\end{figure}

\subsection{Bewertung der Kodierung}
Bei der Kodierung mit Zeitrastern ist die Synchronisierung von entscheidender Bedeutung. Außerdem gilt es den Offset passend zu wählen. Diese Methode hat den Vorteil, dass zum Senden einer 0 keine Nachricht benötigt wird. Kommt es jedoch zu Fehlern im Offset, oder zu plötzlichen Übertragungsschwankungen ist dieses System sehr anfällig, da die Nachrichten in andere Zeitintervalle hineingeraten.

Werden die Paketabstände zu Kodierung verwendet, so wird zum Senden einer 0 eine Nachricht benötigt. Dadurch werden mehr Nachrichten benötigt, die kontinuierlich zu Verfügung stehen müssen.\\
Dabei besteht der Vorteil darin, dass sich nicht um die Synchronisierung gekümmert werden muss. Bei schlechten Netzwerkbedingungen lässt sich die Übertragung pausieren. Hierzu kann einfach die Datenübertragung gestoppt werden. Bei der Codierung mit Rastern würde dieses abrupte Stoppen der Datenübertragung als 0-Werte interpretiert werden.
Bei einer reinen Betrachtung der Differenz zwischen den langen und kurzen Pausen, ist der Sender in der Lage die Sendegeschwindigkeit beliebig anzupassen.

Aufgrund der Vorteile durch die Codierung mit Hilfe der Paketabstände, soll diese Methode in dieser Arbeit verwendet werden. 

\section{Fehlerkorrektur}

\subsection{Paritätsbit}
Die Fehlerkorrektur kann mit einem Paritätsbit realisiert werden. Dieses Bit gibt an, ob die Anzahl der Einsen in einer binären Zahlenfolge eine gerade oder ungerade Zahl ist. Wird bei der Datenübertragung ein Bit verändert, so ändert sich auch die Anzahl der Einsen und stimmt nicht mehr mit dem Paritätsbit überein.

Mit nur einem Paritätsbit lässt sich feststellen, dass ein Fehler aufgetreten ist. Der Fehlerort ist aber nicht bekannt. Um auch dies herauszufinden, kann der so genannte Hammingcode angewendet werden.\\
Bei dieser Codierungsform werden den Datenbits mehrere Paritätsbits hinzugefügt. Mit Hilfe dieser Bits kann dann ein Fehler in den Datenbits gefunden und gezielt korrigiert werden.
\cite{HAMMING}

Die folgende Tabelle zeigt wie viele Paritätsbits zu den Datenbits hinzugefügt werden müssen, um ein falsches Bit in n Datenbits zu korrigieren. 

\begin{tabular}{llllll}
Daten Bits:& 8& 16& 32& 64& 128\\
Paritäts-Bits:& 4& 5& 6& 7& 8\\
Codewort:&12& 21& 38& 71& 136\\
	
\end{tabular}
\cite{HAMMING}

Zum Verschlüsseln prüft jedes Paritätsbit mehrere genau festgelegte Bits des Codeworts. Das Paritätsbit wird dann so gesetzt, dass die Summe der geprüften Bits (sich selbst eingeschlossen) gerade ist.

Um einen Fehler zu erkennen, wird jetzt wieder die Summe ausgerechnet. Ist die Summe gerade, so ist kein Fehler aufgetreten und die Paritätsbits können aus dem Codewort gelöscht werden.
Ist die Summe ungerade ist ein Fehler aufgetreten. Nun müssen alle fehlerhaften Paritätsbits ausfindig gemacht werden.\\
Bildet man nun die Schnittmenge aller, von nicht korrekten Paritätsbits geprüften, Bits und eliminiert alle Bits, die auch von korrekten Paritätsbits geprüft wurden, so bleibt das falsche Bit übrig.
\cite{HAMMING}

Da die Datenübertragung über den Covert Channel auf Grund von Netzwerkschwankungen fehleranfällig ist, empfiehlt es sich den Hammingcode auf jeweils 8 Bits anzuwenden. Dies bedeutet pro Byte 4 zusätzliche Paritätsbits was ein Codewort von 12 Bits Länge ergibt. In diesem Codewort kann ein potentiell falsches Bit ausfindig gemacht und korrigiert werden.

\subsection{Bewertung der Fehlerkorektur}
Da die Fehleranfälligkeit bei schlechten Netzwerkbedingungen und hoher Übertragungsgeschwindigkeit sehr hoch ist, sollte die Fehlerkorrektur auf einen möglichst kleine Anzahl von Bits angewendet werden. Dies hat den Nachteil, dass der Anteil von Paritätsbits bei Verwendung von 8 Bits 50\% und bei 16 Bits 31\% ausmachen würden.\\
Ein weiterer Nachteil ist, dass Fehler oft nacheinander auftreten, da sie von der gleichen Netzwerkverzögerung ausgelöst wurden. Mit dem Hammingcode kann bei mehreren Fehlern ein Fehler detektiert werden, jedoch ist eine Fehlerkorrektur nicht mehr möglich.\\
Bei einer Verwendung von großen Datenpaketen und sehr verstreut auftretenden Fehlern würde die Implementierung des Hamming-Codes Sinn machen, aber in dieser Arbeit wird aus den oben genannten Gründen darauf verzichtet.


\section{Integrität}

Um die Integrität der gesendeten Daten zu gewährleisten, soll am Ende der Daten ein Hashwert mitgesendet werden.

Um die Integrität zu garantieren, bildet der Sender den Hash über die zu sendende Nachricht. Die Nachricht und der Hashwert werden nun versendet. Der Empfänger bildet nun ebenfalls den  Hash über die empfangene Nachricht. Stimmt dieser Hashwert mit dem überein, den er vom Sender bekommen hat, so ist die Nachricht unverändert versendet worden. Die Integrität ist sichergestellt.\\
Stimmt der Hash nicht überein, so müssen die Daten erneut gesendet werden. Es ist auch möglich, den Hash nicht erst am Ende der Datenübertragung zu senden, sondern nach einer festgelegten Datenmenge. Dies hätte den Vorteil, dass nicht die komplette Nachricht wiederholt werden muss.

\subsection{Hash-Funktionen}
	\subsubsection{md5}
	Die md5 Hashfunktion wurde 1991 als Weiterentwicklung der md4 Hashfunktion veröffentlicht. Diese bildet eine beliebige Nachricht auf einen 128-Bit-Hashwert ab. Zu erwähnen ist, dass der md5 aus Sicherheitsgründen nicht mehr empfohlen wird.\cite{watjen2018hashfunktionen}

	\subsubsection{Pearson}
	%TODO                                                                           
	Der Pearson-Algorithmus verwendet eine zufällig initialisierte statische Mapping-Tabelle, um jedes Byte von jedem Hash-Wert auf einen neuen Hash-Wert abzubilden.\cite{davies2010traffic}\\
	Mit diesem simplen Algorithmus lassen sich Hash-Werte mit der Länge von einem Byte erzeugen. Die Mapping-Taballe muss jedoch auf allen beteiligten Systemen gleich sein.
	
	\subsection{Bewertung der Hash-Funktionen}
	Beide Algorithmen verändern sich maßgeblich, wenn ein Bit geändert wird. Der md5 ist auf Grund seiner Länge aber auch komplexeren Algorithmus erheblich sicherer. In dieser Arbeit soll die Sicherheit jedoch allein von der Unauffälligkeit des Covert Channel abhängen. Die Hashfunktion soll nur Sicherstellen, dass die Nachricht unverändert beim Empfänger angekommen ist.\\
	Dazu ist der Pearson Hash ebenfalls in der Lage und hat den Vorteil, dass er nur ein sechzehntel an Datenmenge in Anspruch nimmt.\\ Aus diesen Gründen wird in dieser Arbeit mit dem Pearson Hash gearbeitet. 

\section{Authentizität}
	Die Authentizität wird durch den Pearson-Hash teilweise abgedeckt. Dies gilt aber nur solange die Mapping-Tabelle geheim bleibt. Ist ein Angreifer jedoch in besitzt einer kompletten dekodierten Nachricht, kann er selbst mit Brute-Force in kürzester Zeit die Tabelle rekonstruieren.\\
	Es könnte  ein Public-Key Verfahren eingesetzt werden mit dem zum Beispiel der Hash-Wert verschlüsselt wird. Jedoch würde so eine Methode nicht zu einem auf \textit{Security by obscurity} basierenden Verfahren passen. Auch steht es in Konfrontation mit der Anforderung eine alternative zu verschlüsselten Kommunikationen zu erstellen.

\section{Netzwerkprotokoll}
	\subsection{Anforderung an das Netzwerkprotokoll}
	Die Anforderungen hierfür wurden bereits zum Großteil bei der Wahl des Trägerkanals formuliert. Dabei wird die Nutzung eines TCP basierenden Protokolls festgelegt.\\
	Zusätzlich kommt der Aspekt hinzu, dass sich mit diesem Protokoll legitim große Datenmengen verschicken lassen sollen, ohne Aufmerksamkeit zu erregen. Um der Philosophie von Covert Channels und der Steganographie gerecht zu werden, wird von einer Verschlüsselung abgesehen.
	
	\subsection{HTTP}
	Das Hypertext Transfer Protocol (HTTP) ist ein Protokoll auf Anwendungsebene.
	Es ist ein generisches, zustandsloses Protokoll, das für viele Aufgaben verwendet werden kann.
	HTTP wird zur Versendung von Webseiten und Informationen seit dem Jahr 1990 verwendet.\cite{fielding1999hypertext}\\
	Auch heute stellt es, zusammen mit der verschlüsselten Variante HTTPS, einen elementaren Bestandteil des Internets dar. Dabei besteht die Hauptaufgabe darin, Daten von Webservern in den Browser zu laden.
	\subsection{SMTP}
	Das Simple Mail Transfer Protocol (SMTP) hat die Aufgabe Mail zuverlässig und effizient weiterzuleiten. SMTP Nachrichten und die in ihnen enthaltenen Mails, werden von SMTP Servern entgegengenommen, um sie an den Empfänger weiterzuleiten. Auch die Kommunikation zwischen den SMTP Servern wird mit Hilfe dieses Protokolls realisiert.\cite{klensin2001rfc}
	\subsection{FTP}
	Mit dem File Transfer Protocol (FTP) können Dateien über ein Netzwerk zu einem Server hoch- und heruntergeladen werden. Ebenfalls ist es möglich das Dateisystem auszulesen und auf entfernten Rechnern Dateien zu erstellen, aber auch zu löschen.
	Die hierzu nötige Kommunikation, wird durch das FTP definiert.\cite{postel1985rfc}
	
	\subsection{Bewertung der Netztwerkprotokolle}
	Alle Protokolle basieren auf TCP und verzichten auf eine Verschlüsselung. FTP wird heute in der Regeln aber nicht mehr angewendet, da es von Protokollen wie SFTP und SSH abgelöst wurde. Daher wäre eine Verwendung in dieser Arbeit nicht geeignet.\\
	Auch bei SMTP wird heute vermehrt auf die SSL verschlüsselte Variante zurückgegriffen. Ein weiteres Problem bei SMTP ist, dass die Nachrichten bei großen Paketmengen als Spam interpretiert werden können.\\
	HTTP ist trotz der Einführung von HTTPS im Internet immer noch weit verbreitet und zieht sehr wenig Aufmerksamkeit auf sich. Zusätzlich lässt sich durch die Bereitstellung einer unauffälligen Webseite die wahre Aufgabe des Webservers - die geheime Datenübertragung - verbergen.\\
	Aus diesen Gründen soll in dieser Arbeit ein HTTP Server realisiert werden, der als Sender der geheimen Daten dient.

\section{Server}
	\subsection{Anforderungen an den Server}
	Der Server muss in der Lage sein, einen HTTP Request entgegenzunehmen und im Gegenzug eine Webseite auszuliefern. Da die geheimen Daten vom Server an den Client übertragen werden sollen, muss der Server in der Lage sein, aktiv, ohne Requests, HTTP Nachrichten an den Client zu senden.\\ Zusätzlich ist es für diese Anwendung essentiell, dass sich das Senden der Nachrichten verzögern lässt, um die nötigen zeitlichen Abstände für den Covert Channel zu realisieren. Aus diesem Grund soll der Server frei programmierbar sein und auch Daten verarbeiten können, um beispielsweise Binärdaten zu erstellen, oder einen Hashwert zu generieren.\\
	Der Server soll leichtgewichtig, einfach zu bedienen und auf einem Linux Betriebssystem lauffähig sein.
	
	\subsection{Java HttpServer}
	HttpServer ist eine Java Klasse, die es ermöglicht, einen einfachen HTTP Server zu erstellen.
	Die von Oracle angebotene Klasse implementiert einen Webserver, der an eine IP-Adresse und an einen Port gebunden ist und dort auf eingehende TCP Verbindungen hört.\\
	Um den Server nutzen zu können, müssen ihm ein oder mehrere HttpHandler hinzugefügt werden. Diese bearbeiten, die Anfragen auf verschiedene URL Pfade.\\
	Der HttpServer kann bei der Verwendung der Unterklasse HttpsServer auch verschlüsselte Verbindungen realisieren.\cite{JAVA_HTTP}
	
		
	\subsection{Node.js und Express}
	Node.js ist eine Plattform, ausgerichtet um Netzwerkanwendungen zu erstellen. Dabei ist Node.js eine asynchrone und ereignisgesteuerte JavaScript Runtime. Node.js wird in JavaScript programmiert und kann mit Paketen von npm (Node Paket Manager) erweitert werden.\\
	Als asynchrone Laufzeitumgebung arbeitet Node.js sehr viel mit Callback-Funktionen, die beim Erfüllen von Events ausgeführt werden. Durch die asynchrone Abarbeitung des Programmcodes entsteht eine sehr gut skalierbare Anwendung, die keine Deadlocks generieren kann.\cite{NODE}\\
	Um mit Node.js einen Webserver zu erstellen, kann das Web-Framework Express verwendet werden. Express lässt sich mit Hilfe von npm in das Projekt eingliedern. Das Express Objekt ist in der Lage, auf einen Port auf TCP Verbindungen zu warten und diese entgegenzunehmen. Jedem Pfad ist eine Callback-Funktion zugeordnet, die bei dessen Aufrufen die Abarbeitung der Anfrage übernimmt.\cite{EXPRESS}
	
	
	\subsection{Bewertung des Servers}
	Da der Server in der Lage sein muss HTTP Nachrichten zeitlich verzögert abzuschicken, sind fertige und schwergewichtige Server, wie der Apache oder NGINX ungeeignet.\\
	Bei beiden oben vorgestellten Servern, hat man die Möglichkeit den Datenfluss zu manipulieren und zu verzögern. Da es sich um normalen Java oder JavaScript Code handelt, kann man beliebige Funktionen eigenhändig implementieren und auch aus Dateien lesen. So ist der Java HttpServer und auch Express in der Lage den gewünschten Covert Channel zu realisieren.\\
	Der sehr simple Aufbau und das einfache Hinzufügen und Verwenden von Paketen sprechen für den Node.js Server, weshalb dieser hier verwendet wird. Ein weiterer Vorteil von Node.js ist das einfache Installieren auf einem Linux System. Zusätzlich wird keine IDE benötigt.
	
	\section{Back-End}
		\subsection{Express Implementierung}
			Das importierte Express Paket wird als \textit{app} Objekt in den Code eingebunden. Mit Hilfe dieses Objekts kann definiert werden, wie auf einen Request an eine URL-Route reagiert werden soll.\\
			 Eine Route wird wie in Listing 6.1 gezeigt hinzugefügt. Die mitgegebene Callback-Funktion wird ausgeführt, falls ein GET Request an die ,,Wurzel-Route'' erfolgt. Ist dies der Fall, so wird hier die index.html Seite ausgeliefert.\\
				
			\begin{lstlisting}[caption=Hinzufügen der Stamm-Route]
				app.get('/', function(req, res){
				res.sendFile(__dirname + '/index.html');
				});
				
			\end{lstlisting}
				
				
			Ebenfalls von Express stammt das \textit{http} Objekt, welches den Http Server darstellt. Der Server Port kann wie in Listing 6.2 gewählt werden.\\
			

			\begin{lstlisting}[caption=Wählen des Server Ports]
				http.listen(80, function(){
					console.log('listening on port:80');
				});
					
			\end{lstlisting}
			
			\subsection{Kommunikation des Covert Channel}
				Bei der Express Implementierung wird die \textit{index.html} Datei mit Hilfe von REST (Representational State Transfer) ausgeliefert. REST ist ein Architekturstil, der die Kommunikation zwischen Server und Client regelt. Dieses System beruht darauf, dass ein Server eine beliebige Ressource, wie beispielsweise \textit{index.html}, anbietet. Die wichtigsten Methoden um mit diesen Ressourcen umzugehen sind  GET, PUT, POST und  DELETE.\cite{barton2010modellierung}\\
				Diese Methoden, auf die mit http zugegriffen wird, sehen nicht vor, dass ein Server selbständig und ohne danach gefragt zu werden Nachrichten an den Client sendet.

				\subsubsection{Anforderung an die Kommunikation des Covert Channels}
				Da die Hauptaufgabe des Server das Senden manipulierter Pakete an den Client sein wird, muss eine alternative Kommunikation gefunden werden, die nach dem Ausliefern der Webseite den Nachrichtentransport übernimmt. Dabei muss eine bidirektionale Kommunikation möglich sein. Auch eine einfache Anwendung soll angestrebt werden.
					
				\subsubsection{Websockets}
				
				Das Websocket Protokol baut auf HTTP auf. Bei HTTP wird, nachdem der Client die Antwort vom Server erhalten hat, meistens die Verbindung geschlossen. Bei der Verwendung von Websockets wird die darunterliegende TCP/IP Verbindung weiterverwendet und kann wie ein normaler Netzwerksocket benutzt werden. Dies ermöglicht dem Client und dem Server jeder Zeit Daten zu senden.\cite{abts2015bidirektionale}
					
				\subsubsection{Socket.IO}
				
				Socket.IO ist eine JavaScript-Bibliothek, mit der sich eine bidirektionale Echtzeitkommunikation realisieren lässt. Die Funktion ähnelt einem WebSocket und lässt eine ereignisgesteuerte Kommunikation zwischen Browser und Server zu.\cite{SOCKET_IO}\\
				Um die Verbindung zwischen Server und Client auf jeden Fall sicherzustellen und um so viele Browser wie möglich zu unterstützten, setzt Socket.IO auf mehrere Technologien, wie Websockets, Flash-Sockets oder Comet.\cite{ullrich2012websockets}
				
				
				\subsubsection{Berwertung der Kommunikation des Covert Channels}
				Beide Methoden sind in der Lage den Covert Channel zu realisieren. Jedoch gibt es bei Websockets Probleme mit der Verwendung von Proxys.\\
				Socket.IO stellt eine Erweiterung der WebSockets dar und verfügt über weitere Funktionen, wie zum Beispiel Broadcasting. Aus diesen Gründen und der Tatsache, dass eine sehr komfortable node.js Schnittstelle vorhanden ist, soll hier die Kommunikation mit Socket.IO realisiert werden.
				
			
			\subsection{Socket.IO Implementierung}
			Socket.IO wird in Form des \textit{io} Objekts in den Code eingebunden. Der Verbindungsaufbau ist, wie in Listing 6.3 gezeigt, aufgebaut. Den Events werden ihre jeweiligen Callback-Funktionen zugeordnet.\\
			Wurde eine Verbindung aufgebaut, so sendet der Server eine \textit{test} Nachricht an den Client. Hat der Client diese empfangen, so antwortet dieser mit einem \textit{ClientHello}. Wird diese vom Server empfangen, so wird der jeweilige Socket in ein Array gespeichert und später zum Senden von weiteren Daten verwendet.\\
			
			
			\begin{lstlisting}[caption=Verbindungsaufbau mit Socket.IO]
				io.on('connection', (socket) => {
					var address = socket.handshake.address.replace(/^.*:/, '');
					timestaps.push({ip: address ,time: getMinute()});
				
					socket.emit('test', 'test');
				
					socket.on('ClientHello', function (data) {
						console.log("Client connected");
						socken.push(socket);
					});
				
			\end{lstlisting}
				
		
		\subsection{Geheime Daten}
		Die geheimen Daten werden vom Dateisystem gelesen und anschließend mit Hilfe des npm Paketes \textit{buffer-bits} in einen Bit-String umgewandelt.
				
		\subsection{Pearson Hash Implementierung}
		Um die Pearson Hash-Funktion auf die Daten anzuwenden, muss eine Mapping-Tabelle mit den Werten von 0-255 in zufälliger Reihenfolge generiert werden. Diese lässt sich beispielsweise mit einem Python Script unter Verwendung der \textit{shuffel} Funktion erstellen.\\
		Die hier generierte Tabelle muss beim Server, sowie beim Client bekannt sein, um bei gleicher Hash-Funktion und gleichen Daten den identischen Hashwert zu generieren.\\
		Den Algorithmus zur Berechnung des Hashs ist in Listing 6.4 gezeigt.
		Hier wird am Anfang ein Hash-Wert \textit{h} generiert. Dieser wird bitweise XOR mit dem Datenwert verknüpft. Der entstandene Wert wird als Index in der Mapping-Tabelle verwendet. Der dortige Wert in der Mapping-Tabelle, wird der neue Wert \textit{h}. Dies wird so lange wiederholt, bis alle Datenwerte verwendet worden sind. 
		
		\begin{lstlisting}[caption=Erstellen der Mapping-Table]
					
					for (var j = 0; j < hashLength; j++){  
						var h = table[(parseInt(data.charAt(0)) + j) % 256];
						for (var i = 1; i < data.length; i++){
							h = tabel[(h ^ data[i])];          // XOR
						}
						hash[j] = h;
					}
		
		\end{lstlisting}
		
		Da hier mit einer \textit{hashLength} von 1 gearbeitet wird, ist das Ergebnis ein 8 Bit-Wert, der nun an die Daten angehängt werden kann.
		
		\subsection{Covert Channel Implementierung}
		
		Um den Covert Channel zu implementieren, werden Nachrichten zeitlich verzögert an den Client gesendet. Grundsätzlich kann jede beliebige Nachricht an den Client gesendet werden. Hier wird zum Testen die aktuelle Uhrzeit verwendet.\\
		Die Länge der Pause zwischen den Daten hängt davon ab, ob eine 1 oder eine 0 übertragen werden soll. Eine 1 wird durch eine lange, eine 0 durch eine kurze Pause festgelegt.\\
		Zur Definition der Pausen wird die lange Pause in Millisekunden angegeben. Zusätzlich wird ein Faktor festgelegt, der das Verhältnis zwischen der langen und kurzen Pause angibt. Durch die Variation von Pausenlänge und Faktor kann der Covert Channel eingestellt und optimiert werden.
		Ist eine komplette Datei übertragen, wird eine vorab definierte Pause von einer Sekunde eingelegt. Danach beginnt die Datenübertragung erneut.
		
		\begin{lstlisting}[caption=Covert Channel]
		
					async function covertChannel(){
						while (true) {
							if (fileLoad == true) {
								for(i = 0; i < dataBits.length; i++){
									if(socken.length != 0){
										socken[0].emit('time', getTimeString());
									}
									if(dataBits[i] == "1"){
										await sleep(longBreak);
									}
									else {
										await sleep(shortBreak);
									}
								}
								if(socken.length != 0){
									socken[0].emit('time', getTimeString());
								}
							}
							await sleep(breakBetweenTransmit);
						}
					}
		
		\end{lstlisting}
	\section{Front-End}
		\subsection{HTML}
		
		Das Front-End wird durch eine einfache HTML-Seite ausgeliefert. Die Funktion der Webseite ist vorerst das Anzeigen der aktuellen Uhrzeit. Diese Uhrzeit wird vom Server empfangen und danach im Browser angezeigt.\\
		
		\subsection{JQuery}
		
		JQuery ist eine JavaScript Bibliothek, die es wesentlich einfacher macht, das HTML-Dokument und den DOM-Baum zu manipulieren und zu verändern. In diesem wird es dazu verwendet, um jeweils die aktuelle Uhrzeit dynamisch auf der Seite anzuzeigen.\\
		Zudem kommt es zum Einsatz, um die Eventhandler für Socket.IO einzubinden.
		
		
		\subsection{Socket.IO}
		Der nötige Code wird für das Paket  über ein Script Tag heruntergeladen und entsprechend hinzugefügt. Wie auch serverseitig, kann hier ein SocketIO Objekt generiert werden.
		Diesem werden die Events zum Empfangen der Nachrichten, dem Verbindungsaufbau und dem Empfangen der Zeitpakete hinzugefügt.\\
		
		
	\section{Clientseitige Auswertung des Covert Channel}
		Die vom Server erhaltenen Pakete und vor allem die zeitlichen Abstände zwischen den Paketen müssen ausgewertet werden, um die geheime Nachricht zu rekonstruieren.
		
		\subsection{Anforderung an die Auswertung}
		Für die Auswertung muss eine Anwendung geschrieben werden, die die eingehenden Nachrichten vom Server analysiert. Dazu muss der exakte Zeitpunk des Eintreffens der Pakete so genau wie möglich aufgezeichnet werden. Nach dem Rekonstruieren der geheimen Nachricht, muss diese auf das Dateisystem abgespeichert werden. Ein weiterer, wichtiger Aspekt ist, dass es für Dritte möglichst schwierig sein soll, die Analyse des Covert Channels zu bemerken.
		
		\subsection{Auswertung im Front-End}
		Bei der Auswertung im Front-End werden die Daten direkt nach dem Empfangen im Browser ausgewertet. Hier sind die nötigen Funktionen mit JavaScript geschrieben. Sobald die Nachricht beim Browser ankommt, wird die Event Callback-Funktion ausgeführt, die den aktuellen Zeitstempel abspeichert.
		
		\subsection{Auswertung mit einem externen Programm}
		Bei der Auswertung mit einem externen Programm, hat eine zweite, browserunabhängige Anwendung die Aufgabe, die eingehenden Nachrichten zu interpretieren. Dazu muss die Anwendung in der Lage sein, den Netzwerkverkehr mitzulesen und den Zeitpunkt des Eintreffens abzuspeichern und zu interpretieren.
		
		\subsection{Bewertung der Covert Channel Auswertung}
		Die Auswertung direkt im Front-End hat den Vorteil, dass kein zweites Programm benötigt wird. So ist diese Variante ressourcenschonender und vereinfacht die tatsächliche Anwendung.\\
		Die Auswertung direkt im Front-End hat jedoch einen großen Nachteil. Der Front-End Code wird an jeden versendet, der die Seite aufruft. So kommen Dritte, die möglicherweise die Kommunikation abhören, an den Sourcecode, der den Covert Channel auswertet. Zusätzlich wäre dadurch der Algorithmus der Hash-Funktion bekannt und auch die zugehörige Mapping-Tabelle. Dies würde einem Dritten, der als Man-in-the-Middle zwischen dem Server und Client steht, die Möglichkeit geben, selbst Nachrichten zu verfassen oder diese zu manipulieren.\\
		Aus diesen Gründen wird die Auswertung des Covert Channel durch ein externes Programm realisiert.
	
\section{Client}
	Der Client stellt hier den Empfänger des Covert Channels dar. Wie im vorhergehenden Kapitel festgelegt, soll dieser als externes Programm realisiert werden, das unabhängig vom Browser ist.
	
	\subsection{Programmiersprache}
		\subsubsection{Anforderung an die Programmiersprache}
			Die zu verwendende Programmiersprache muss in der Lage sein, Daten effizient zu verarbeiten. Eine harte Echtzeit ist jedoch nicht nötig. Es soll ein Programm entstehen, das auf allen Unix Systemen lauffähig ist und das sich über die Konsole oder ein Shell-Script öffnen lässt.\\
			Es soll möglichst einfach sein, ein anderes Konsolenprogramm zu öffnen und dessen Output zu empfangen und auszuwerten. Was in Kapitel 6.12.2 näher erläutert wird.
			
		\subsubsection{Java}
			Java ist eine objektorientierte Programmiersprache, dessen Code auf mehr als 3 Milliarden Geräten ausgeführt wird. Der Java Code orientiert sich an C++, aber auch an anderen Skript Sprachen.\\
			Der Java Code wird von einem Compiler in Bytecode umgewandelt. Dieser kann auf jedem Gerät, das die Java Runtime besitzt, ausgeführt werden. Dadurch muss der Code nicht mehr für jedes Gerät compiliert werden.\cite{ullenboom2004java}
			
		\subsubsection{Python}
			Python ist eine objektorientierte Skript Sprache. Der Code wird als lesbares Skript an den Anwender übergeben und von einem Python Interpreter ausgewertet. So wird kein Compiler und auch nicht unbedingt eine IDE benötigt.
			Die Python Syntax ist so entworfen, dass die Skripte sehr gut lesbar und auch wiederverwendbar sind.\\
			Trotzdem ist der Code sehr kompakt und hat in der Regel ein Drittel bis ein Fünftel der Codelänge von traditionellen Programmiersprachen wie Java oder C++.\cite{weigend2006objektorientierte}
		\subsubsection{Bewertung der Programmiersprache}
			Beide Programmiersprachen sind in der Lage das Clientprogramm zu realisieren. Java zeigt im direkten Vergleich mit Python eine bessere Performance. Python hingegen ist besser dafür geeignet, um mit zusätzlichen Konsolenprogrammen zu arbeiten und bringt von Haus aus viele Funktionen mit, die bei der Datenverarbeitung helfen. Da es sich hier nicht um ein komerzielles Projekt handelt, kann das Skript einfach verbreitet und nach Bedarf angepasst werden.
			Aus diesen Gründen wird in diesem Projekt Python als Programmiersprache verwendet.
	
	
	
	\subsection{Mitschneiden der Datenenpakete}
		Paket-Sniffer sind Programme, die in der Lage sind, den Netzwerkverkehr auf den verschieden Interfaces aufzuzeichnen und für den Benutzter zu veranschaulichen. Ein solches Programm soll hier verwendet werden, um die Datenpakete mitzuschneiden.
	
		\subsubsection{Anforderungen an den Paket-Sniffer}
		Der Paket-Sniffer soll sich über die Konsole öffnen lassen und die Ergebnisse in eine Pipe schreiben. Das Tool soll frei für alle UNIX Systeme erhältlich sein. Die Pakete sollen möglichst korrekt mitgeschnitten und der Eintreffzeitpunkt des Pakets ausgegeben werden.\\
		Zusätzlich soll das Filtern der Pakete möglich sein, um die mitgeschnittenen Pakete auf die vom sendenden Server einzugrenzen.
		
		\subsubsection{tcpdump}
		tcpdump ist eine Konsolenanwendung für UNIX Systeme, die die empfangenen Netzwerkpakete an einer Netzwerkschnittstelle ausgibt. Dabei basiert tcpdump auf der Betriebssystemschnittstelle \textit{libpcap}. Es lassen sich ebenfalls Filter einstellen, die beispielsweise nur Pakete von einem bestimmten Host aufzeichnen. \cite{jacobson2003tcpdump} 

		\subsubsection{tshark}
		tshark ist eine Version von Wireshark, die dessen volle Funktion in der Konsole aufrufbar macht. tshark ist ein sehr mächtiges Tool um Netzwerkpakete nicht nur aufzuzeichnen, sondern auch zu Decodieren. Es lassen sich ebenfalls unzählige Filter realisieren.\cite{TSHARK}

		\subsubsection{Bewertung der Paket-Sniffer}
		tshark hat einen größern Funktionsumfang. In diesem Projekt wird aber nur der Zeitstempel der Nachricht benötigt. tcpdump ist hierzu in der Lage und hat ebenfalls den Vorteil, dass er bei vielen UNIX Systemen wie zum Beispiel Ubuntu bereits vorhanden ist und nicht installiert werden muss. 
		
		\subsubsection{Implementierung}
		Für das Öffnen und anschließende Mitschneiden der Daten wird ein eigener Thread gestartet. Hier wird zuerst mit \textit{os.popen} ein neuer Prozess erstellt in dem tcpdump läuft. Die nötigen Parameter für die Einstellung des Filters werden ebenfalls übergeben. Der Rückgabewert ist hier ein \textit{open file object}, in welches die Pipe zu tcpdump die Ergebnisse schreibt.
		Aus diesem \textit{open file object} kann die tcpdump Ausgabe gelesen und der Empfangszeitpunkt in einen Buffer gespeichert werden.\\
		Die Zeitstempel werden dann kontinuierlich in ein globales Datenarray geschrieben. Um Kollisionen zu vermeiden, wird ein Mutex verwendet.
		
		\begin{lstlisting}[caption=Paket-Sniffing]
			   	pipe = os.popen("tcpdump -s 0 host "+host+" and src port "+port+" -q -i any -l")
					for line in pipe:
						buffer.append(line[0:15])
						
						if len(buffer) > bufferzize:
							mutex.acquire()
							data = data + buffer
							buffer = []
							mutex.release()
		\end{lstlisting}
		
	\subsection{Interpretieren der Zeitstempel}
		Die Zeitstempel vom tcpdump-Thread sollen ausgewertet werden. Dafür werden die als String abgespeicherten Zeitstempel in \textit{datetime} Objekte geparst, um mit ihnen Rechnen zu können.\\
		Die hiermit berechneten zeitlichen Differenzen werden entweder als eine binäre 1, oder 0 interpretiert. Wie auch schon serverseitig, wird die Geschwindigkeit des Covert Channels durch die Angabe der langen Pause und dem Faktor, der den Unterschied zwischen der langen und der kurzen Pause beschreibt, definiert.\\
		So kann zum Beispiel eine lange Pause als 50 Millisekunden und der Faktor als 0.5 definiert werden. Daraus ergibt sich eine kurze Pause von 25 Millisekunden.
	
	\subsubsection{Toleranz}
		Da die Zeiten mit sechs Nachkommastellen angegeben werden, ist es unmöglich, dass die Pausen exakt der Angabe entsprechen. Durch Verzögerungen, Schwankungen in der Netzwerkgeschwindigkeit, aber auch durch Prozess-Scheduling, kann es zu Abweichungen kommen.\\
		Deshalb muss die Pause nicht als ein fester Zeitpunkt, sondern als Zeitfenster definiert werden. Ist die Länge der Differenz zwischen den Paketen im jeweiligen Zeitfenster enthalten, kann sie entsprechend interpretiert werden. Falls nicht, wird dieses Paket ignoriert.\\
		Die Zeitfenster werden durch die prozentuale Angabe, relativ zur Pausenlänge, in positiver und negativer Richtung angegeben.\\
		Wird die Pause mit 50 Millisekunden, einer positiven Toleranz von 30\% und einer negativen Toleranz von 10\% angegeben, ergibt sich ein Zeitfenster zwischen 45 und 65 Millisekunden.\\
		Da nur die Differenz der Nachrichten betrachtet wird, können Nachrichten auch zu früh kommen, wenn die vorhergehende Nachricht erheblich zu spät war. Aus diesem Grund muss das Zeitfenster auch  in negativer Richtung erweitert werden.\\
		Von der Einstellung dieser Toleranzfenster hängt erheblich die Qualität der empfangenen Daten ab.\\
		Der nachstehende Code zeigt, wie eine Klassifizierung der Differenz, hier \textit{f1} genannt, in die Zeitfenster realisiert ist.
	
		
		\begin{lstlisting}[caption=Interpretation mit Zeitfenstern]
			if write == True:
				if sBigBreakTolerance < f1 < bBigBreakTolerance:   
					codedata.append("1")
					print(str(f1) + "  \t=> 1 ")    
				else:
					if sSmallBreakTolerance < f1 < bSmallBreakTolerance: 
						codedata.append("0")
						print(str(f1) + "  \t=> 0")
					else:
						print(str(f1) + "  \t=> undefind: will be ignored")
		\end{lstlisting}
		
		
	\subsection{Verarbeiten der Erhaltenen Daten}
		Von den erhaltenen Daten werden die letzten 8 Bit abgeschnitten. Dies ist der Hash-Wert vom Server. Um die Daten zu validieren, wird auf diese ebenfalls die Hash-Funktion angewendet. Stimmt der Hash-Wert mit dem vom Server überein, so wird die Datei ins Dateisystem geschrieben.\\
		Damit die Daten nicht UTF8-Codiert auf die Datei geschrieben werden, wird das Paket \textit{BitArray} verwendet, welches es möglich macht, die binären Daten zu schreiben.\\
		Die Datei oder Nachricht ist hiermit erfolgreich übertragen.
		
\chapter{Optimales Einstellen und Anwendung des Covert Channel} 
		Es gilt nun den Covert Channel so optimal wie möglich einzustellen. Dazu muss die beste Kombination aus Pausenlänge und Zeitfenster gefunden werden.\\
		Gezielte Test-Datenübertragungen sollen Aufschluss zu diesen Werten geben. Um reale Netzwerkbedingungen zu schaffen, wird der Server auf einem 1\&1 Cloud Server in Karlsruhe gehosted. Das Ergebnis eines TCP-Pings ergibt eine Übertragungsdauer von 30 ms zum Server. Bei allen Tests wird eine Testdatei mit 12 Byte (Hallo Welt) verwendet.\\
	
		
		
		\subsection{Verhältnis nicht interpretierbar/ interpretierbar}
		Der erste Test ist die Ermittlung des Verhältnisses zwischen interpretierbaren und nicht interpretierbaren Zeitstempeln. Interpretierbar ist ein Zeitstempel, wenn er sich entweder im Zeitfenster für Nullen, oder Einsen befindet.\\
		Die Ergebnisse dieses Tests sind in Tabelle 6.1 zu sehen. Die Spalten zeigen, jeweils die Länge einer langen Pause in Sekunden. Die Zeilen stehen für den prozentualen Anteil an der Pausenlänge, die das Zeitfenster definiert.\\
		Die Ergebnisse sind in Prozent angegeben. Die Länge der kurzen Pausen beträgt die Hälfte der langen.\\ Ein Wert von 0 Prozent spiegelt eine Übertragung wieder, bei der alle Zeitstempel interpretiert werden konnten. Liegt der Wert bei 100 Prozent waren die Anzahl interpretierter und nicht interpretierter Zeitstempel gleich.\\
		Aus der Tabelle lässt sich ableiten, dass ein Zeitfenster mit 20\% nicht zum Optimum führt, da hier die Werte für eine stabile Datenübertragung zu hoch sind. Auch die Übertragung mit einer Pausenlänge von 0,03 ms ist nicht geeignet.\\
		
		Da dieser Test jedoch keine Fehlinterpretationen betrachtet, muss noch ein weiterer Test hinzugefügt werden.
		
	 \begin{table}[h!]
  \centering
	\begin{tabular}{c|c|c|c}
		
		& \textbf{0,08} & \textbf{0,05} & \textbf{0,03} \\\hline
		
		20\%&1,26 & 66,44 & 96,53 \\
		
		30\%&0,62& 1,74 & 82,87\\
		40\%&0,26&0,31&2,49\\
		50\%&0,20&0,1&0,95\\
		
	\end{tabular}
	\caption{Verhätniss nicht interpretierbar/ interpretierbar}
 \end{table}
		

	Diese Erkenntnisse decken sich auch mit dem auf Bild 4.2 gezeigten Ergebnissen von \cite{cabuk2004ip} 

	\subsection{Anzahl korrekt übertragener Dateien}
	Bei diesem Test soll die Korrektheit der ankommenden Daten begutachtet werden. Dazu werden für jede mögliche Kombination 20 Datenübertragungen durchgeführt und die Anzahl der korrekt übertragenen Dateien gezählt. Dadurch ergibt sich folgende Tabelle:
	
	
		 \begin{table}[h!]
		\centering
		\begin{tabular}{c|c|c|c}
			
			& \textbf{0,08} & \textbf{0,05} & \textbf{0,03} \\\hline
			
			20\%&11 & 0 & 0 \\
			30\%&14& 10 & 0\\
			40\%&15&9&0\\
			50\%&0&0&0\\
			
		\end{tabular}
		\caption{Korrekt übertragene Dateien}
	\end{table}
	
	Zusätzlich zu den im ersten Test ausgeschlossenen Zeilen und Spalten, kann nun auch die Zeile mit einem 50\%igem Zeitfenster ausgeschlossen werden. Den guten Werten dieses Zeitfensters im ersten Test steht eine nahezu 100 \%-ige Fehlinterpretation gegenüber.
	
	\subsection{Zeit bis zum ersten korrekten Eintreffen der Datei}
	Nachdem durch die ersten beiden Tests  Kombinationen ausgeschlossen werden konnten, sind nun noch die Kombinationen 30\%/0,08s, 40\%/0,08s, 30\%/0,05s und 40\%/0,05s übrig.\\
	Um hieraus das Optimum zu ermitteln, wird ein Test durchgeführt, der einer realen Anwendung am nächsten kommt.
	Es wird die Zeit bis zum ersten korrekten Eintreffen einer gesendeten Datei gemessen.\\
	Diese Messung wird jeweils für alle Kombinationen 10 mal ausgeführt. Die Ergebnisse sind in Bild 6.5 zu sehen.
	
	
	\begin{figure}[h!]
		\centering
		\includegraphics*[height=10cm]{bilder/Test31.png}
		\caption{Zeit bis zum ersten korrekten Eintreffen}
		\label{fig19}
	\end{figure}
	
	In Tabelle 7.3 sind die Durchschnittswerte gezeigt, die sich aus diesem Test ergeben.\\
	
	\begin{table}[h!]
		\centering
		\begin{tabular}{c|c|c}
			
			& \textbf{0,08} & \textbf{0,05} \\\hline
			30\%&8,956&12,418\\
			40\%&9,004&9,114\\			
		\end{tabular}
		\caption{Durchschnittliche Zeiten}
	\end{table}
	
	
	Aus der Graphik in Abbildung 7.1 lässt sich erkennen, dass die Werte der Kombination aus 0,3\%/0,05s (gelb) enorme Schwankungen beinhalten. Auch der höchste Durchschnittswert mit 12,418 Sekunden spricht gegen die Verwendung dieser Kombination. Bei den Werten 30\%/0,08s sind die besten Durchschnittswerte aufgetreten, weshalb diese auf jeden Fall als Einstellungswerte zugelassen werden. Ebenfalls sehr vielversprechend ist die Kombination aus 40\%/0,05s (grün). Hier zeigt die Grafik, bis auf einen Ausschlag bei der ersten Messung, sehr niedrige Werte.\\
	
	Um ein eindeutigeres Ergebnis zu schaffen, werden noch weitere Messungen mit den Kombinationen 30\%/0,08s und 40\%/0,05s durchgeführt.\\
	
	\begin{figure}[h!]
		\centering
		\includegraphics*[height=10cm]{bilder/Test32.png}
		\caption{Zeit bis zum ersten korrekten Eintreffen}
		\label{fig193}
	\end{figure}
	
	Die Grafik in Bild 7.2 zeigt die Zeiten der eingesetzten Werte. Bei der Verwendung der Werte 30\%/0,08s (blau) lässt sich eine höhere Konstanz erkennen. Hier werden deutlich mehr Daten auf den ersten Versuch korrekt übertragen. Das ist bei 40\%/0,05s seltener der Fall, jedoch ist hier die mögliche Übertragungsgeschwindigkeit auf Grund der kleineren Pausen größer. Trotz größerer Schwankungen, ist die durchschnittliche Zeit von 40\%/0,05s mit 8,327s kleiner als die von 30\%/0,08s mit 9,095s.\\
	
	Die Kombination aus einem Zeitfenster von 40\% und einer große Pause von 0,05 Sekunden ist die optimale Lösung für diesen Covert Channel.


		\subsection{Padding zum Synchronisieren}

Bei der Anwendung in einem realen Netzwerk treten am Anfang des Sendevorgangs erhebliche Schwankungen in der Übertragungszeit auf. Diese Abweichungen könnten dem allgemeinen Routing oder dem Verbindungsaufbau von Socket.IO entspringen.\\
Um dieses Problem zu umgehen, werden 2 Byte Padding, zum Synchronisieren, an den Anfang der Dateien gestellt. Der Abstand zwischen diesen Paketen ist auf 0.01 Sekunden festgelegt. In Abbildung 7.1 ist zu sehen, dass mindestens 6 Datenpakete benötigt werden, bis sich der Korrekte Paketabstand einstellt.

\begin{figure}[h!]
	\centering
	\includegraphics*[height=6cm]{bilder/sync.png}
	\caption{Fehler in den ersten Paketen}
	\label{fig34}
\end{figure}


\chapter{Umsetzung der passiven Variante}
	Die in Abbildung 6.2 dargestellte passive Lösungsvariante des Covert Channels soll in diesem Kapitel betrachtet werden. Diese Variante hat den Vorteil, dass als Server jeder beliebige Webserver verwendet werden kann. Die Codierung wird von einem Proxy realisiert.\\
	Für die Proof of Concept Implementierung wird hier der Client der aktiven Variante wiederverwendet. Im Browser des Clients muss die Verwendung eines Proxys eingetragen werden.

	\subsection{Anforderung an den Proxy}
		Der Proxy hat die Aufgabe, TCP Nachrichten von einem Client an einen Server zu senden. Die Nachrichten sollen bidirektional durch den Proxy geschleust werden. Nachrichten vom Client werden an den Server weitergeleitet, ebenso wie umgekehrt. Dabei soll der Inhalt der Nachrichten nicht verändert werden. Wie bei der aktiven Variante, soll der Proxy in der Lage sein, die TCP Pakete zeitlich zu verzögern, um so die geheimen Daten zu übertragen.\\
		Der Proxy soll auf einem Linux System lauffähig sein.
	
	\subsection{Lösungsansätze}
		\subsubsection{Veränderung eines Open-Source Proxys}
			Ein Lösungsansatz ist die Verwendung eines fertigen Proxys, wie zum Beispiel eines Squid oder Tinyproxy. Für diese Open Source Programme ist der Code frei erhältlich. Hier gilt es die Funktion zum Senden der Nachrichten so zu verändern, dass die Nachrichten gezielt verzögert werden können.
		
		\subsubsection{Proxy selbst programmieren}
			Eine alternative Lösung ist die eigenständige Programmierung eines Proxys. Dazu soll ein Python-Skript geschrieben werden, das jeweils ein Netzwerksocket zum Client und zum Server verwaltet. Werden die TCP Pakete von einem an den anderen Socket weitergegeben, erhält man einen Proxy. Die Pakete können hier frei verändert werden.
	
	\subsection{Bewertung des Lösungsansatzes}
			Beide Lösungsansätze sind in der Lage die Anforderungen umzusetzen. Der selbst programmierte Proxy bietet die volle Kontrolle, bei gleichzeitig mehr Spielraum für diese Proof of Concept Implementierung. Zudem ist diese sehr leichtgewichtige Software Variante komfortabler zu debuggen und zu optimieren. Aus diesen Gründen soll hier der Proxy eigenhändig erstellt werden.\\
			Sollte sich der Proof of Concept als Erfolg herausstellen, ist die erste Lösung für eine reale Anwendung besser geeignet, da ein großer Funktionsumfang mitgenutzt werden kann.
	
	\subsection{Implementierung}
		\subsubsection{Sockets}
			Es wird ein Listen-Socket erstellt, der auf eingehende Nachrichten auf Port \textit{80} hört. Dieser Port muss später in den Proxy-Einstellungen des Browsers hinterlegt werden.\\
			Sendet der Browser einen HTTP-Request an den Proxy, wird ein Client-Socket erstellt. Der Proxy erstellt ebenfalls einen Server-Socket, indem er sich mit dem, im HTTP-Request stehenden Webserver verbindet. Da oft externe Ressourcen verwendet werden und Verbindungen nach dem Senden einer Datei geschlossen werden, entstehen pro Webseite mehrere solcher Verbindungen.\\
			Um die hierdurch entstehenden Sockets zu verwalten, wird das Betriebssystemmodul \textit{select} verwendet. \textit{select} stellt fest, ob die angegebenen Sockets zum Lesen oder Schreiben bereit sind. Ist dies der Fall wird eine Liste mit beschreibbaren und eine mit lesbaren Sockets zurückgegeben. Dadurch müssen nicht alle Sockets dauerhaft mit Polling abgefragt werden müssen.\\
			In Listing 7.1 ist der Code zu sehen, der die oben beschriebene Handhabung der Sockets übernimmt. Die Liste aller Sockets wird zur Kontrolle an \textit{select} übergeben.
			
			\begin{lstlisting}[caption=Socket Handling]
while True:
	readable, writable, exceptional = select.select(self.lsock, self.lsock, self.lsock)
	
	self.read(readable)
	self.send(writable)
			\end{lstlisting}
			 
			 Anhand ihres Indexes in der Socket-Liste, können die Sockets identifiziert werden. Dabei gehören immer ein Client- und ein Server-Socket zusammen. Die Nachrichten die zwischen diesen zwei ausgetauscht werden sollen, werden in einem Array gespeichert.\\
			
		\subsubsection{Geheime Daten}
			Vergleichbar mit der aktiven Variante, werden die zu übertragenden Daten von einer angegebenen Datei gelesen und in eine binäre Liste umgewandelt. Hieraus wird ein 8 Bit Pearson-Hash berechnet und an das Ende der binären Liste angehängt.
			
		\subsubsection{Covert Channel}
			Bei der Erstellung des Covert Channels müssen die Nachrichten an den Client zeitlich verzögert werden. Dabei besteht allerdings das Problem, dass bei dieser Anwendung nur ein Thread verwendet wird, der gleichzeitig für das Senden und Empfangen zuständig ist.\\ Auf Grund dessen kann der Lösungsansatz der aktiven Variante, wobei der Thread für die benötigte Zeit in \textit{sleep} gesetzt wird, nicht verwendet werden.\\
			Daher wird nach jedem Senden an den Client der Zeitstempel abgespeichert. Bevor ein neues Paket gesendet wird, wird kontrolliert, ob die Differenz der aktuellen Zeit und dem letzten Sendezeitpunkt der gewünschten Pause entspricht.\\
			Die Pausen werden äquivalent zu der aktiven Variante definiert.
			
	
\chapter{Anwendung des passiven Covert Channel}
	
	\section{Probleme bei realen Webseiten}
	
			\subsection{HTTPS}
				Der Proxy ist nicht für die Verwendung von HTTPS ausgelegt, wodurch hier nur HTTP Webseiten abgerufen werden können. 
	
			\subsection{Generierung einer ausreichenden Anzahl von Netzwerkpaketen}
				Für den Covert Channel wird ein kontinuierlicher Datenstrom benötigt. Durch den verbindungsorientierten Aufbau von TCP ist es schwierig, die Daten zu puffern und später auf einmal abzusenden, da auf das ACK-Flag gewartet wird.\\
				Um künstlich einen hohen Netzwerkverkehr zu generieren, kann beim Empfangen der Daten eine geringe Paketgröße gesetzt werden.\\
				In diesem Fall wird eine maximale Paketgröße von 256 Byte gewählt. Dadurch wird gerade beim Empfangen von Bildern ein enormer Netzwerkverkehr erzeugt, welcher für den Covert Channel genutzt werden kann.
				
	
			\subsection{Parallele Datenabfrage}	
				Wie vorhergehnd bereits beschrieben, öffnet ein Webserver gleich mehrerer Sockets, um parallel Daten zu empfangen. Diese Nachrichtenpakete, der einzelnen Sockets können nicht vom Client auseinander gehalten werden, da dieser nur den Source-Port betrachtet, der jedoch bei allen Paketen gleich.\\
				In Bild 7.1 ist ein Ausschnitt aus den Firefox Development Tool zu sehen. Hier wird die Übertragungsdauer der einzelnen Dateien gezeigt. Dabei fällt auf, dass bei der hier verwendeten Webseite der \textit{PH-Weingarten}, 5 CSS Dateien gleichzeitig übertragen werden.\\
				Diese 5 daraus entstehenden Covert Channels überschneiden sich bei der Interpretation im Client und sind so nicht mehr auswertbar.\\
				Der Covert Channel funktioniert nur, wenn genau eine Datei übertragen wird. Oft dauert die Übertragung großer Bilder jedoch länger als die von Quellcode. Dies bietet die Chance, dass am Ende der Übertragung nur noch ein Socket für die Bildübertragung aktiv ist. Dieser kann für die Datenübertragung im Covert Channel genutzt werden kann.
				
				\begin{figure}[h!]
					\centering
					\includegraphics*[height=7cm]{bilder/ParallelProblem.png}
					\caption{Parallele Datenabfrage}
					\label{fig43}
				\end{figure}
				
				Als mögliche Lösung kann der Client zur Berücksichtigung der Sequenznummer erweitert werden, um die verschiedenen Covert Channel zu unterscheiden.
	
	
		\section{Test mit realen Servern}
		Um die Funktion des Proxys zu testen und reale Netzwerkbedingungen zu schaffen, wird er auf einem 1\&1 Cloud Server installiert. Die zu übertragende Datei ist eine Textdatei mit 12 Byte. Zur Datenübertragung werden die gleichen zeitlichen Einstellungen verwendet, die bereits im Kapitel 7 evaluiert wurden. Das bedeutet, die Lange Pause hat eine Länge von 0,08 Sekunden und das Zeitfenster entspricht jeweils 30\%.
		Als Client wird das Programm der aktiven Variante verwendet. Um genügend Netzwerkverkehr zu generieren, wird die maximale Paketgröße vom Server zum Client auf 256 Byte festgelegt.\\
		Um den Proxy nutzen zu können, muss dieser im Browser eingetragen werden. Dadurch werden alle HTTP Nachrichten zuerst an den Proxy weitergeleitet.\\
		Nun wird eine beliebige Webseite gewählt, die als Paketquelle dient. Diese Seite muss jedoch über HTTP ausgeliefert werden. Hier wird die Webseite der Pädagogischen-Hochschule Weingarten mit der Adresse \textit{http://www.ph-weingarten.de/} verwendet.
		Wird die Webseite geladen, so sendet der Webserver der PH-Weingarten die Webseitendateien über den Proxy an den Client.\\
		Jedoch besteht anfangs, das im vorhergehenden Kapitel beschriebene, Problem mit der parallelen Datenübertragung. Das Ergebnis ist in Bild 9.2 zu sehen. Bei einer optimalen Funktion werden den zeitlichen Differenzen links binären Werte zugeordnet. Daher gelingt die Zuordnung in den meisten Fällen nicht.
		
		
		\begin{figure}[h!]
			\centering
			\includegraphics*[height=7cm]{bilder/ProxyFail.png}
			\caption{Fehlinterpretation des Clients}
			\label{fig33}
		\end{figure}
	
		Ist nur noch ein Socket aktiv, der für die Dateiübertragung eines größeren Bilds zuständig ist, so findet die Datenübertragung wie in Bild 9.3 gezeigt statt. Dies ist der beste Zeitpunkt, die Datenübertragung via Covert Channel zu starten . Fehler treten von diesem Zeitpunkt an nur noch aufgrund von Netzwerk- oder Serveranomalien auf.\\
		Die Datei kann erfolgreich übertragen werden.
		
		
		\begin{figure}[h!]
			\centering
			\includegraphics*[height=9cm]{bilder/SucProxy.png}
			\caption{Korrekte Interpretation des Clients}
			\label{fig339}
		\end{figure}
			
				
\chapter{Evaluierung}	
		Das Ergebnis dieser Arbeit benutzt einen Covert Channel, als eine Methode des Information-Hiding, um Daten zu übertragen. Dabei können die Daten jedes beliebige Format annehmen, da diese in ihrer binären Form übertragen werden. Die für diesen Covert Channel höchst mögliche Übertragungsgeschwindigkeit wurde ermittelt und kann auch angewendet werden. Es gibt jedoch andere Covert Channels, wie beispielsweise Storage Channels, die zu deutlich höheren Übertragungsgeschwindigkeiten fähig sind. Der Kanal ist als Algorithmus umsetzbar, was durch die Realisierung mittels eins Computerprogramms gezeigt worden ist. Dadurch, dass der Covert Channel unabhängig vom Paketinhalt ist, lässt er sich nicht von Netzwerk-Normalisierungen beeinflussen. Er ist jedoch stark von Netzwerkbedingungen abhängig, was mit der Manipulation der Zeitabstände einhergeht.\\
		Die Umsetzung des Covert Channels ist sowohl als aktive, als auch passive Variante möglich, was durch die erfolgreichen Implementierungen gezeigt worden ist.\\ Auf Probleme stößt man jedoch bei der passiven Lösung, wenn vom Webserver Dateien parallel übertragen werden. Für die aktive Variante stellte sich die Schwankungen beim Übertragungsstart als problematisch dar. Abhilfe konnte durch das Voranstellen von Synchronisationsbits geschafft werden.
			



\chapter{Fazit und Ausblick}

		\section{Aktiv}
		Der Server und sowie Client sind in der Lage einen Covert Channel zu erstellen, der in der Lage ist, Daten zu übertragen. Die Kommunikation geschieht verdeckt, kommt aber ohne Verschlüsselung aus.\\
		Das in der Motivation genannte Beispiel lässt sich mit dieser Lösung umsetzten. Es können Daten jeglicher Größe übertragen werden. Jedoch macht eine Größe über 25 Byte keinen Sinn, da sonst die Chance auf falsch interpretierte Bits zu groß wird. Die entstandene Softwarelösung bietet jedoch eine gute Basis, um entsprechende Erweiterungen zu implementieren.\\
		Mit einer durchschnittlichen Datenübertragungsrate von 11,53 Bits pro Sekunde ist der Covert Channel nicht sehr schnell, aber ausreichend, um kleinere Datenmengen zu übertragen.\\
		Wird der Covert Channel zur Kommunikation verwendet, ist es für Dritte nahezu unmöglich eine verdeckte Kommunikation zu erkennen. Wird der Server so getarnt, dass er nicht mit einem Sender, wie zum Beispiel der Polizei, in Verbindung gebracht werden kann, so stellt diese Lösung eine sehr sichere Variante dar, um kurze Nachrichten wie Treffpunkte, Anweisungen oder Telefonnummern auszutauschen.

		
		\section{Passiv}
		Die passive Variante des Covert Channels ist eine \textit{Proof of Cocept} Implementierung und noch nicht geeignet, um als reale Anwendung verwendet zu werden. Das Konzept eines passiven, zeitlichen Cover Channel wurde bestätigt und dessen Funktion bewiesen.\\
		Wie auch bei der aktiven Variante ist eine Datengröße über 25 Byte nicht sinnvoll. Es ist aber eine gute Basis entstanden, die erweitert werden kann. Durch die Einschränkungen ist es nicht einfach, eine geeignete Webseite für den Covert Channel zu finden. Bei einer realen Umsetzung sollte die Verwendung des ersten Lösungsansatzes in Betracht gezogen werden. Dabei kann man auf einer funktionierenden Proxylösung aufbauen, bei der alle Webseiten unterstützt werden.\\
		Dennoch kann man mit der Kombination aus Proxy und Client, Netzwerkpakete eines fremden Servers verwenden, um Informationen ohne Veränderung des Paketinhalts zu versenden.
		

\section{Ausblick}
In diesem Kapitel werden einige mögliche Erweiterungen vorgestellt, die in Zukunft implementiert werden könnten, beziehungsweise sollten, um eine reale Anwendung zu schaffen.


\subsubsection{Dateien aufteilen}
Um auch große Dateien zu verschicken, können diese in mehrere kleine aufgeteilt werden. Es müsste jedoch eine Methode gefunden werden, um die Datei Fragmente wieder zusammenzusetzen.


\subsubsection{Automatische Pausenerkennung}
Um die Bedienung komfortabler zu machen, kann eine automatische Erkennung der Pausenlänge implementiert werden. So wird eine variable Anpassung der Pausenlänge möglich. Diese Anpassung kann vom Server oder Proxy als Reaktion auf eine Netzwerkanomalie veranlasst werden.

\subsubsection{Beachtung der Sequence Number beim Client}
Um das derzeitige Problem bei der parallelen Datenübertragung zu lösen, kann zusätzlich zur Erkennung der Pakete die TCP Sequence Number beachtet werden. So könnten die verschiedenen Übertragungen der Dateien unterschieden werden. Damit wäre sogar eine parallele Datenübertragung möglich.

\subsubsection{Server mit realistischer Webseite}
Die derzeitige Webseite zeigt die aktuelle Uhrzeit an. Um den Covert Channel noch sicherer und unauffälliger zu machen, kann eine Webseite implementiert werden, die einen plausiblen Einsatzzweck hat.


\subsubsection{Verwendung von HTTPS}
Um wirklich alle Webseiten verwenden zu können, muss der Proxy in der Lage sein HTTPS Pakete weiterzuleiten. Es macht ebefalls Sinn den Server mit einer verschlüsselten Verbindung auszustatten.







