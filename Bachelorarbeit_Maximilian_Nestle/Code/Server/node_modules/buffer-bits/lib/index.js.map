{"version":3,"sources":["index.js"],"names":["BARS","getBARS","count","exports","module","buffer","offset","length","_isLeftAligned","_length","_buffer","Buffer","alloc","copy","_startOffset","_byteLength","byteLength","lastOffset","nextOffset","lastByteOffset","nextByteOffset","lastBitOffset","nextBitOffset","byteValue","anotherBits","startOffset","buff","Bits","from","totalBitLength","buffByteLength","isSmaller","i","result","undefined","alignRight","readIntBE","alignLeft","readUIntBE","readIntLE","readUIntLE","encoding","start","end","toString","index","Error","get","value","set","byteOffset","bitOffset","align","isLeftAligned","bufBitsLength","shiftBitsLength","shr","shl","binString","readBit","buf","bufLength","len"],"mappings":"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","file":"index.js","sourcesContent":["import BitEncode from 'bit-encode'\nimport BufferShift from 'buffershift'\n\nconst BARS = [0, 1, 3, 7, 15, 31, 63, 127, 255]\n\nfunction getBARS(count) {\n    return BARS[count]\n}\n\nexports = module.exports = class Bits {\n\n\n    /**\n     * Creates an instance of Bits.\n     * @deprecated Don't use new Bits, there's no params checking here\n     * @param {any} buffer \n     * @param {any} offset \n     * @param {any} length \n     * \n     * @memberof Bits\n     */\n    constructor(buffer, offset, length) {\n        this._isLeftAligned = false\n        this._length = length\n\n        // offset = 0, length = buffer.length, just copy...\n        if (offset == 0 && length == (buffer.length << 3)) {\n            this._buffer = Buffer.alloc(buffer.length)\n            buffer.copy(this._buffer, 0, 0, buffer.length)\n            this._startOffset = 0\n            this._byteLength = buffer.length\n            return\n        }\n\n        // byteLength for allocating the new Buffer\n        let byteLength = ((length - 1) >> 3) + 1\n\n        // (offset + length) & 7 == 0, just copy, too\n        if (((offset + length) & BARS[3]) == 0) {\n            this._buffer = Buffer.alloc(byteLength)\n            buffer.copy(this._buffer, 0, offset >> 3, (offset + length) >> 3)\n            this._startOffset = offset & BARS[3]\n            if (byteLength > 0) {\n                this._buffer[0] &= BARS[8 - this._startOffset]\n            }\n            this._byteLength = byteLength\n            return\n        }\n\n        // byteOffset is the byte position inside the buffer\n        let lastOffset = offset + length\n        this._buffer = Buffer.alloc(byteLength)\n\n        let count = byteLength;\n        while (lastOffset >= offset) {\n            let nextOffset = lastOffset - 8\n            if (nextOffset <= offset) {\n                // less than one byte left\n                nextOffset = offset\n            }\n            let lastByteOffset = (lastOffset - 1) >> 3\n            let nextByteOffset = (nextOffset - 1) >> 3\n            let lastBitOffset = lastOffset & BARS[3]\n            let nextBitOffset = nextOffset & BARS[3]\n            let byteValue = 0\n            if (lastByteOffset == nextByteOffset) {\n                // in the same byte\n                byteValue = (buffer[lastByteOffset] >> (8 - lastBitOffset)) & BARS[lastBitOffset - nextBitOffset]\n            } else {\n                // cutted byte\n                byteValue = ((buffer[nextByteOffset] & BARS[(8 - nextBitOffset)]) << nextBitOffset) + (buffer[lastByteOffset] >> (8 - lastBitOffset))\n            }\n\n            // put the byteValue to our new buffer\n            this._buffer[count-- - 1] = byteValue\n            lastOffset -= 8\n        }\n\n        this._startOffset = (byteLength << 3) - length\n        this._byteLength = byteLength\n    }\n\n    /**\n     * Initialize the Bits object\n     * \n     * @static\n     * @param {Buffer|Bits} buffer \n     * @param {Number} offset \n     * @param {Number} length \n     * \n     * @memberof Bits\n     */\n    static from(buffer, offset, length) {\n        if (!(buffer instanceof Buffer || buffer instanceof Bits)) {\n            throw new Error('Invalid type \\'buffer\\', should be either a [Buffer] or [Bits]')\n        }\n        if (offset === undefined) {\n            offset = 0\n        }\n        let buf = null\n        let bufBitsLength = null\n        let bufLength = null\n        let startOffset = offset\n        let len = length\n        if (buffer instanceof Buffer) {\n            buf = buffer\n            bufBitsLength = buffer.length << 3\n            bufLength = bufBitsLength\n        } else if (buffer instanceof Bits) {\n            buf = buffer.buffer\n            bufBitsLength = buffer.length\n            bufLength = buf.length << 3\n            startOffset = buffer.startOffset + offset\n        } else {\n            return undefined\n        }\n\n        if (length === undefined) {\n            len = bufBitsLength - offset\n        }\n\n        if ((bufBitsLength) < len || (bufLength) < (startOffset + len)) {\n            throw new Error('Out Of range')\n        }\n\n        return new Bits(buf, startOffset, len)\n    }\n\n\n    /**\n     * Alloc a Bits object with bit length set\n     * \n     * @static\n     * @param {Number} length \n     */\n    static alloc(length) {\n        let byteLength = ((length - 1) >> 3) + 1\n        let buffer = Buffer.alloc(byteLength)\n        return Bits.from(buffer, (byteLength << 3) - length, length)\n    }\n\n\n    /**\n     * Build new Bits object by concat another Bits\n     * \n     * @param {any} anotherBits \n     * @returns \n     * \n     * @memberof Bits\n     */\n    concat(anotherBits) {\n        if (anotherBits.startOffset == 0) {\n            // no bits move\n            let buff = Buffer.alloc(this._byteLength + anotherBits.byteLength)\n            anotherBits.buffer.copy(buff, this._byteLength, 0, anotherBits.byteLength)\n            this._buffer.copy(buff, 0, 0, this._byteLength)\n            return Bits.from(buff, this._startOffset, (buff.length << 3) - this._startOffset)\n        } else {\n            // need to move bits...\n            let totalBitLength = this._length + anotherBits.length\n            let buffByteLength = ((totalBitLength - 1) >> 3) + 1\n            let isSmaller = false\n            if (buffByteLength < this._byteLength + anotherBits.byteLength) {\n                isSmaller = true\n            }\n            let buff = Buffer.alloc(buffByteLength)\n            // still copy the right Bits\n            anotherBits.buffer.copy(buff, buffByteLength - anotherBits.byteLength, 0, anotherBits.byteLength)\n            for (let i = this._byteLength - 1; i >= 0; i--) {\n                if (isSmaller) {\n                    buff[i] += (this._buffer[i] << (8 - anotherBits.startOffset))\n                } else {\n                    buff[i + 1] += (this._buffer[i] << (8 - anotherBits.startOffset))\n                    if (i == 0) {\n                        // need to put the first byte in buff\n                        buff[0] = this._buffer[0] >> anotherBits.startOffset\n                    }\n                }\n            }\n            return Bits.from(buff, (buff.length << 3) - totalBitLength, totalBitLength)\n        }\n    }\n\n    get length() {\n        return this._length\n    }\n\n    get buffer() {\n        return this._buffer\n    }\n\n    get startOffset() {\n        return this._startOffset\n    }\n\n    get byteLength() {\n        return this._byteLength\n    }\n\n    get isLeftAligned() {\n        return this._isLeftAligned\n    }\n\n    get isRightAligned() {\n        return !this._isLeftAligned\n    }\n\n    get isFullByte() {\n        return (this._length & BARS[3]) === 0\n    }\n\n    readInt() {\n        let result = undefined\n        if (this._isLeftAligned) {\n            this.alignRight()\n            result = this._buffer.readIntBE(0, this._byteLength)\n            this.alignLeft()\n        } else {\n            result = this._buffer.readIntBE(0, this._byteLength)\n        }\n        return result\n    }\n\n    readUInt() {\n        let result = undefined\n        if (this._isLeftAligned) {\n            this.alignRight()\n            result = this._buffer.readUIntBE(0, this._byteLength)\n            this.alignLeft()\n        } else {\n            result = this._buffer.readUIntBE(0, this._byteLength)\n        }\n        return result\n    }\n\n    readIntLE() {\n        let result = undefined\n        if (this._isLeftAligned) {\n            this.alignRight()\n            result = this._buffer.readIntLE(0, this._byteLength)\n            this.alignLeft()\n        } else {\n            result = this._buffer.readIntLE(0, this._byteLength)\n        }\n        return result\n    }\n\n    readUIntLE() {\n        let result = undefined\n        if (this._isLeftAligned) {\n            this.alignRight()\n            result = this._buffer.readUIntLE(0, this._byteLength)\n            this.alignLeft()\n        } else {\n            result = this._buffer.readUIntLE(0, this._byteLength)\n        }\n        return result\n    }\n\n    readString(encoding, start, end) {\n        let result = undefined\n        if (!this._isLeftAligned) {\n            this.alignLeft()\n            result = this._buffer.toString(encoding, start, end)\n            this.alignRight()\n        } else {\n            result = this._buffer.toString(encoding, start, end)\n        }\n        return result\n    }\n\n    readBit(index) {\n        if (index >= this.length || index < 0) {\n            throw new Error('Out of range')\n        }\n        return BitEncode.get(this._buffer, this._startOffset + index)\n    }\n\n    setBit(index, value) {\n        if (index >= this.length || index < 0) {\n            throw new Error('Out of range')\n        }\n        BitEncode.set(this._buffer, this._startOffset + index, value)\n    }\n\n    toggleBit(index) {\n        if (index >= this.length || index < 0) {\n            throw new Error('Out of range')\n        }\n        // BitEncode.set(this._buffer,\n        //     this._startOffset + index,\n        //     !BitEncode.get(this._buffer, this._startOffset + index))\n\n        let byteOffset = (this._startOffset + index) >> 3\n        let bitOffset = (this.startOffset + index) & BARS[3]\n        this._buffer[byteOffset] ^= (1 << (7 - bitOffset))\n    }\n\n    alignLeft() {\n        this.align(true)\n    }\n\n    alignRight() {\n        this.align(false)\n    }\n\n    align(isLeftAligned) {\n        let bufBitsLength = this._byteLength << 3\n        if (this._isLeftAligned && !isLeftAligned && this._length < bufBitsLength) {\n            // need to align right\n            let shiftBitsLength = bufBitsLength - this._length\n            BufferShift.shr(this._buffer, shiftBitsLength)\n            this._startOffset = shiftBitsLength\n            this._isLeftAligned = false\n        }\n\n        if (!this._isLeftAligned && isLeftAligned && this._length < bufBitsLength) {\n            // need to align left\n            BufferShift.shl(this._buffer, bufBitsLength - this._length)\n            this._startOffset = 0\n            this._isLeftAligned = true\n        }\n\n        // else do nothing\n    }\n\n    toggleAll() {\n        for (let i = 0; i < this._byteLength; i++) {\n            this._buffer[i] ^= BARS[8]\n        }\n    }\n\n    toString() {\n        return '[Bits Object]'\n    }\n\n    toBinaryString() {\n        let binString = '';\n        for (let i = 0; i < this._length; i++) {\n            binString += this.readBit(i) ? '1' : '0'\n        }\n        return '0b' + binString\n    }\n\n    equals(anotherBits) {\n        if (anotherBits instanceof Bits) {\n            if (this._length != anotherBits.length) {\n                return false;\n            }\n\n            for (let i = 0; i < this._byteLength; i++) {\n                if (i == 0) {\n                    if ((this._buffer[0] ^ anotherBits.buffer[0]) & BARS[8 - this._startOffset] != 0) {\n                        return false;\n                    }\n                } else {\n                    if ((this._buffer[i] ^ anotherBits.buffer[i]) != 0) {\n                        return false;\n                    }\n                }\n            }\n        } else {\n            return false\n        }\n\n        return true\n    }\n}"],"sourceRoot":"C:\\git\\github\\buffer-bits\\src"}