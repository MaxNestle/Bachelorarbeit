'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bitEncode = require('bit-encode');

var _bitEncode2 = _interopRequireDefault(_bitEncode);

var _buffershift = require('buffershift');

var _buffershift2 = _interopRequireDefault(_buffershift);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BARS = [0, 1, 3, 7, 15, 31, 63, 127, 255];

function getBARS(count) {
    return BARS[count];
}

exports = module.exports = function () {

    /**
     * Creates an instance of Bits.
     * @deprecated Don't use new Bits, there's no params checking here
     * @param {any} buffer 
     * @param {any} offset 
     * @param {any} length 
     * 
     * @memberof Bits
     */
    function Bits(buffer, offset, length) {
        _classCallCheck(this, Bits);

        this._isLeftAligned = false;
        this._length = length;

        // offset = 0, length = buffer.length, just copy...
        if (offset == 0 && length == buffer.length << 3) {
            this._buffer = Buffer.alloc(buffer.length);
            buffer.copy(this._buffer, 0, 0, buffer.length);
            this._startOffset = 0;
            this._byteLength = buffer.length;
            return;
        }

        // byteLength for allocating the new Buffer
        var byteLength = (length - 1 >> 3) + 1;

        // (offset + length) & 7 == 0, just copy, too
        if ((offset + length & BARS[3]) == 0) {
            this._buffer = Buffer.alloc(byteLength);
            buffer.copy(this._buffer, 0, offset >> 3, offset + length >> 3);
            this._startOffset = offset & BARS[3];
            if (byteLength > 0) {
                this._buffer[0] &= BARS[8 - this._startOffset];
            }
            this._byteLength = byteLength;
            return;
        }

        // byteOffset is the byte position inside the buffer
        var lastOffset = offset + length;
        this._buffer = Buffer.alloc(byteLength);

        var count = byteLength;
        while (lastOffset >= offset) {
            var nextOffset = lastOffset - 8;
            if (nextOffset <= offset) {
                // less than one byte left
                nextOffset = offset;
            }
            var lastByteOffset = lastOffset - 1 >> 3;
            var nextByteOffset = nextOffset - 1 >> 3;
            var lastBitOffset = lastOffset & BARS[3];
            var nextBitOffset = nextOffset & BARS[3];
            var byteValue = 0;
            if (lastByteOffset == nextByteOffset) {
                // in the same byte
                byteValue = buffer[lastByteOffset] >> 8 - lastBitOffset & BARS[lastBitOffset - nextBitOffset];
            } else {
                // cutted byte
                byteValue = ((buffer[nextByteOffset] & BARS[8 - nextBitOffset]) << nextBitOffset) + (buffer[lastByteOffset] >> 8 - lastBitOffset);
            }

            // put the byteValue to our new buffer
            this._buffer[count-- - 1] = byteValue;
            lastOffset -= 8;
        }

        this._startOffset = (byteLength << 3) - length;
        this._byteLength = byteLength;
    }

    /**
     * Initialize the Bits object
     * 
     * @static
     * @param {Buffer|Bits} buffer 
     * @param {Number} offset 
     * @param {Number} length 
     * 
     * @memberof Bits
     */


    _createClass(Bits, [{
        key: 'concat',


        /**
         * Build new Bits object by concat another Bits
         * 
         * @param {any} anotherBits 
         * @returns 
         * 
         * @memberof Bits
         */
        value: function concat(anotherBits) {
            if (anotherBits.startOffset == 0) {
                // no bits move
                var buff = Buffer.alloc(this._byteLength + anotherBits.byteLength);
                anotherBits.buffer.copy(buff, this._byteLength, 0, anotherBits.byteLength);
                this._buffer.copy(buff, 0, 0, this._byteLength);
                return Bits.from(buff, this._startOffset, (buff.length << 3) - this._startOffset);
            } else {
                // need to move bits...
                var totalBitLength = this._length + anotherBits.length;
                var buffByteLength = (totalBitLength - 1 >> 3) + 1;
                var isSmaller = false;
                if (buffByteLength < this._byteLength + anotherBits.byteLength) {
                    isSmaller = true;
                }
                var _buff = Buffer.alloc(buffByteLength);
                // still copy the right Bits
                anotherBits.buffer.copy(_buff, buffByteLength - anotherBits.byteLength, 0, anotherBits.byteLength);
                for (var i = this._byteLength - 1; i >= 0; i--) {
                    if (isSmaller) {
                        _buff[i] += this._buffer[i] << 8 - anotherBits.startOffset;
                    } else {
                        _buff[i + 1] += this._buffer[i] << 8 - anotherBits.startOffset;
                        if (i == 0) {
                            // need to put the first byte in buff
                            _buff[0] = this._buffer[0] >> anotherBits.startOffset;
                        }
                    }
                }
                return Bits.from(_buff, (_buff.length << 3) - totalBitLength, totalBitLength);
            }
        }
    }, {
        key: 'readInt',
        value: function readInt() {
            var result = undefined;
            if (this._isLeftAligned) {
                this.alignRight();
                result = this._buffer.readIntBE(0, this._byteLength);
                this.alignLeft();
            } else {
                result = this._buffer.readIntBE(0, this._byteLength);
            }
            return result;
        }
    }, {
        key: 'readUInt',
        value: function readUInt() {
            var result = undefined;
            if (this._isLeftAligned) {
                this.alignRight();
                result = this._buffer.readUIntBE(0, this._byteLength);
                this.alignLeft();
            } else {
                result = this._buffer.readUIntBE(0, this._byteLength);
            }
            return result;
        }
    }, {
        key: 'readIntLE',
        value: function readIntLE() {
            var result = undefined;
            if (this._isLeftAligned) {
                this.alignRight();
                result = this._buffer.readIntLE(0, this._byteLength);
                this.alignLeft();
            } else {
                result = this._buffer.readIntLE(0, this._byteLength);
            }
            return result;
        }
    }, {
        key: 'readUIntLE',
        value: function readUIntLE() {
            var result = undefined;
            if (this._isLeftAligned) {
                this.alignRight();
                result = this._buffer.readUIntLE(0, this._byteLength);
                this.alignLeft();
            } else {
                result = this._buffer.readUIntLE(0, this._byteLength);
            }
            return result;
        }
    }, {
        key: 'readString',
        value: function readString(encoding, start, end) {
            var result = undefined;
            if (!this._isLeftAligned) {
                this.alignLeft();
                result = this._buffer.toString(encoding, start, end);
                this.alignRight();
            } else {
                result = this._buffer.toString(encoding, start, end);
            }
            return result;
        }
    }, {
        key: 'readBit',
        value: function readBit(index) {
            if (index >= this.length || index < 0) {
                throw new Error('Out of range');
            }
            return _bitEncode2.default.get(this._buffer, this._startOffset + index);
        }
    }, {
        key: 'setBit',
        value: function setBit(index, value) {
            if (index >= this.length || index < 0) {
                throw new Error('Out of range');
            }
            _bitEncode2.default.set(this._buffer, this._startOffset + index, value);
        }
    }, {
        key: 'toggleBit',
        value: function toggleBit(index) {
            if (index >= this.length || index < 0) {
                throw new Error('Out of range');
            }
            // BitEncode.set(this._buffer,
            //     this._startOffset + index,
            //     !BitEncode.get(this._buffer, this._startOffset + index))

            var byteOffset = this._startOffset + index >> 3;
            var bitOffset = this.startOffset + index & BARS[3];
            this._buffer[byteOffset] ^= 1 << 7 - bitOffset;
        }
    }, {
        key: 'alignLeft',
        value: function alignLeft() {
            this.align(true);
        }
    }, {
        key: 'alignRight',
        value: function alignRight() {
            this.align(false);
        }
    }, {
        key: 'align',
        value: function align(isLeftAligned) {
            var bufBitsLength = this._byteLength << 3;
            if (this._isLeftAligned && !isLeftAligned && this._length < bufBitsLength) {
                // need to align right
                var shiftBitsLength = bufBitsLength - this._length;
                _buffershift2.default.shr(this._buffer, shiftBitsLength);
                this._startOffset = shiftBitsLength;
                this._isLeftAligned = false;
            }

            if (!this._isLeftAligned && isLeftAligned && this._length < bufBitsLength) {
                // need to align left
                _buffershift2.default.shl(this._buffer, bufBitsLength - this._length);
                this._startOffset = 0;
                this._isLeftAligned = true;
            }

            // else do nothing
        }
    }, {
        key: 'toggleAll',
        value: function toggleAll() {
            for (var i = 0; i < this._byteLength; i++) {
                this._buffer[i] ^= BARS[8];
            }
        }
    }, {
        key: 'toString',
        value: function toString() {
            return '[Bits Object]';
        }
    }, {
        key: 'toBinaryString',
        value: function toBinaryString() {
            var binString = '';
            for (var i = 0; i < this._length; i++) {
                binString += this.readBit(i) ? '1' : '0';
            }
            return '0b' + binString;
        }
    }, {
        key: 'equals',
        value: function equals(anotherBits) {
            if (anotherBits instanceof Bits) {
                if (this._length != anotherBits.length) {
                    return false;
                }

                for (var i = 0; i < this._byteLength; i++) {
                    if (i == 0) {
                        if ((this._buffer[0] ^ anotherBits.buffer[0]) & BARS[8 - this._startOffset] != 0) {
                            return false;
                        }
                    } else {
                        if ((this._buffer[i] ^ anotherBits.buffer[i]) != 0) {
                            return false;
                        }
                    }
                }
            } else {
                return false;
            }

            return true;
        }
    }, {
        key: 'length',
        get: function get() {
            return this._length;
        }
    }, {
        key: 'buffer',
        get: function get() {
            return this._buffer;
        }
    }, {
        key: 'startOffset',
        get: function get() {
            return this._startOffset;
        }
    }, {
        key: 'byteLength',
        get: function get() {
            return this._byteLength;
        }
    }, {
        key: 'isLeftAligned',
        get: function get() {
            return this._isLeftAligned;
        }
    }, {
        key: 'isRightAligned',
        get: function get() {
            return !this._isLeftAligned;
        }
    }, {
        key: 'isFullByte',
        get: function get() {
            return (this._length & BARS[3]) === 0;
        }
    }], [{
        key: 'from',
        value: function from(buffer, offset, length) {
            if (!(buffer instanceof Buffer || buffer instanceof Bits)) {
                throw new Error('Invalid type \'buffer\', should be either a [Buffer] or [Bits]');
            }
            if (offset === undefined) {
                offset = 0;
            }
            var buf = null;
            var bufBitsLength = null;
            var bufLength = null;
            var startOffset = offset;
            var len = length;
            if (buffer instanceof Buffer) {
                buf = buffer;
                bufBitsLength = buffer.length << 3;
                bufLength = bufBitsLength;
            } else if (buffer instanceof Bits) {
                buf = buffer.buffer;
                bufBitsLength = buffer.length;
                bufLength = buf.length << 3;
                startOffset = buffer.startOffset + offset;
            } else {
                return undefined;
            }

            if (length === undefined) {
                len = bufBitsLength - offset;
            }

            if (bufBitsLength < len || bufLength < startOffset + len) {
                throw new Error('Out Of range');
            }

            return new Bits(buf, startOffset, len);
        }

        /**
         * Alloc a Bits object with bit length set
         * 
         * @static
         * @param {Number} length 
         */

    }, {
        key: 'alloc',
        value: function alloc(length) {
            var byteLength = (length - 1 >> 3) + 1;
            var buffer = Buffer.alloc(byteLength);
            return Bits.from(buffer, (byteLength << 3) - length, length);
        }
    }]);

    return Bits;
}();
//# sourceMappingURL=index.js.map
